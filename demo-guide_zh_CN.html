<!DOCTYPE html>
<!-- @author babyfish-ct@163.com -->
<html>
    <head>
        <meta charset="utf-8" />
        <title>BabyFish Demo Guide(Chinese)</title>
        <style type="text/css">
            body {
                margin: 0px;
            }
            body {
                font-size: 14px;
                font-family: Arial;
                overflow-x: hidden;
            }
            table {
                width: 100%;
                border-collapse: collapse;
            }
            div.fill {
                position: absolute;
                left: 0px;
                top: 0px;
                right: 0px;
                bottom: 0px;
            }
            div.v-splitter {
                display: flex;
                flex-direction: column;
                align-items: stretch;
            }
            div.v-splitter > div.top {
                flex-shrink: 0;
            }
            div.v-splitter > div.bottom {
                flex-grow: 1;
                flex-shrink: 1;
            }
            div.h-splitter {
                display: flex;
                align-items: stretch;
                position: relative;
            }
            div.h-splitter > div.left {
                flex-shrink: 0;
                width: 400px;
            }
            div.h-splitter > div.drag {
                flex-shrink: 0;
                cursor: col-resize;
                box-sizing: border-box;
                background-color: darkblue;
                width: 10px;
                position: relative;
                box-sizing: border-box;
            }
            div.h-splitter > div.drag > div.button {
                position: absolute;
                box-sizing: border-box;
                left: 0px;
                right: 0px;
                top: 50%;
                height: 30px;
                transform: translateY(-50%);
                background-color: white;
                color: darkblue;
                font-size: 10px;
                cursor: pointer;
            }
            div.h-splitter > div.drag > div.button:hover {
                background-color: #7777ff;
            }
            div.h-splitter > div.drag > div.button > div.arrow {
                position: absolute;
                box-sizing: border-box;
                left: 0px;
                right: 0px;
                top: 50%;
                transform: translateY(-50%);
                text-align: center;
            }
            div.h-splitter > div.dragging {
                position: absolute;
                width: 10px;
                top: 0px;
                bottom: 0px;
                box-sizing: border-box;
                background-color: black;
                opacity: .7;
                display: none;
                cursor: col-resize;
            }
            div.h-splitter > div.right {
                flex-grow: 1;
            }
            div.h-splitter > div.left, div.h-splitter > div.right {
                box-sizing: border-box;
                position: relative;
                padding: 0px 20px 20px 20px;
                overflow: auto;
            }
            div.h-splitter > div.left > div.no-pointer-events, div.h-splitter > div.right > div.no-pointer-events {
                /* the css property "pointer-events" is not supported by fuckable IE, mock it */
                position: absolute;
                left: 0px;
                top: 0px;
                right: 0px;
                bottom: 0px;
                display: none;
                cursor: col-resize;
            }
            div.title-bar {
                display: flex;
                flex-direction: row;
                padding: 10px;
                background-color: rgb(0, 0, 100);
                align-items: center;
            }
            div.title {
                flex-flow: 1;
                text-align: center;
                font-weight: bold;
                font-size: 40px;
                color: white;
                flex-basis: 100%;
            }
            div.main {
                font-size:24px;
            }
            div.not-main {
                font-size: 16px;
                padding: 10px;
            }
            div.catalog {
                white-space: nowrap;
            }
            div.catalog div.sub-catalog {
                border-left: dotted 1px gray;
                padding-left: 8px;
                margin-left: 11px; /* 1 + 8 + 11 = 20 */
            }
            div.catalog a {
                text-decoration: none;
                display: inline-block;
            }
            div.catalog a > span.chapter-number, fieldset.tree-node > legend span.chapter-number {
                color: gray;
                font-style: italic;
            }
            div.catalog a, div.catalog a:visited {
                color: black;
            }
            div.catalog a.selected, div.catalog a.selected > span,
            div.document a.selected, div.document a.selected>a {
                background-color: darkblue;
                color: white;
            }
            div.document a.selected:after {
                content: ' (Selected in catalog)';
                font-style: italic;
                font-weight: normal;
                color: white;
            }
            div.document a.soft-selected, div.document a.soft-selected > a {
                border: 2px dashed darkblue;
            }
            div.document a.hash-link {
                text-decoration: none;
                border: solid 1px gray;
                background-color: #aaaaff;
            }
            button.large {
                font-size: 15px;
                line-height: 15px;
                height: 30px;
                box-sizing: border-box;
                border: none 0px white;
                background:-webkit-linear-gradient(top, #fff, #bbb);
                background:-moz-linear-gradient(top, #fff, #bbb);
                background:-o-linear-gradient(top, #fff, #bbb);
                background:linear-gradient(top, #fff, #bbb);
                background-color: #ddd;
            }
            button.large:hover {
                background:-webkit-linear-gradient(top, #fed, #ba9);
                background:-moz-linear-gradient(top, #fed, #ba9);
                background:-o-linear-gradient(top, #fed, #ba9);
                background:linear-gradient(top, #fed, #ba9);
                background-color: #dcb;
            }
            button.large:active {
                background:-webkit-linear-gradient(top, #ba9, #fed);
                background:-moz-linear-gradient(top, #ba9, #fed);
                background:-o-linear-gradient(top, #ba9, #fed);
                background:linear-gradient(top, #ba9, #fed);
                background-color: #dcb;
            }
            button.large-group-start {
                padding-left: 15px;
                border-left: solid 1px gray;
                border-top: solid 1px gray;
                border-bottom: solid 1px gray;
                border-radius: 15px 0px 0px 15px;
            }
            button.large-group-end {
                border: solid 1px gray;
                padding-right: 15px;
                border-radius: 0px 15px 15px 0px;
            }
            fieldset.tree-node {
                border: none;
                border-left: dotted 1px gray;
                padding: 0px 0px 0px 8px;
                margin: 10px 0px 10px 11px; /* 1 + 8 + 11 = 20 */
            }
            fieldset.tree-node > legend {
                margin-left: -20px;
                padding: 0px;
                line-height: 24px;
                vertical-align: middle;
                color: rgb(0, 0, 127);
                display: inline-block;
            }
            span.variable {
                font-weight: bold;
                color: rgb(104, 23, 23);
            }
            span.expand-all, span.collapse-all, span.expanded, span.collapsed, span.category, span.project {
                display: inline-block;
                box-sizing: border-box;
                width: 24px;
                height: 24px;
                background-repeat: no-repeat;
            }
            span.folder, span.package, span.file, span.method {
                display: inline-block;
                box-sizing: border-box;
                width: 16px;
                height: 16px;
                background-repeat: no-repeat;
            }
            fieldset.folder span.expanded,
            fieldset.folder span.collapsed,
            div.catalog div.folder span.expanded,
            div.catalog div.folder span.collapsed {
                height: 18px;
                background-position-y: -4px;
            }
            fieldset.package span.expanded, fieldset.file span.expanded, fieldset.method span.expanded,
            fieldset.package span.collapsed, fieldset.file span.collapsed, fieldset.method span.collapsed,
            div.catalog div.package span.expanded, div.catalog div.file span.expanded, div.catalog div.method span.expanded,
            div.catalog div.package span.collapsed, div.catalog div.file span.collapsed, div.catalog div.method span.collapsed {
                height: 16px;
                background-position-y: -4px;
            }
            fieldset.category > legend, div.catalog div.category {
                font-size: 24px;
            }
            fieldset.project > legend, div.catalog div.project {
                font-size: 22px;
            }
            fieldset.folder > legend, div.catalog div.folder {
                font-size: 20px;
            }
            fieldset.package > legend, div.catalog div.package {
                font-size: 18px;
            }
            fieldset.file> legend, div.catalog div.file {
                font-size: 16px;
            }
            fieldset.method > legend, div.catalog div.method {
                font-size: 14px;
            }
            fieldset.category {
                font-size: 19px;
            }
            fieldset.project {
                font-size: 18px;
            }
            fieldset.folder {
                font-size: 17px;
            }
            fieldset.package {
                font-size: 16px;
            }
            fieldset.file {
                font-size: 15px;
            }
            fieldset.method {
                font-size: 14px;
            }
            span.expanded, span.collapsed {
                background-color: white;
            }
            span.expanded:hover, span.collapsed:hover {
                background-color: rgb(200, 200, 200);
            }
            span.expanded {
                background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEwAACxMBAJqcGAAAAGNJREFUSIntzbENgDAMRNFfkR42YUxYBlLDSlkBGhcWSlJYToP869M9iKKo1wJswNTZJGAHZgtwAw9wNJAEZNlcFmAFSgPR50W2pjRyCuJ2XkOy93kNcT//IkPONTLsPIr+2gsEwx4NLAopngAAAABJRU5ErkJggg==');
            }
            span.collapsed {
                background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEwAACxMBAJqcGAAAAGlJREFUSIljYBgFowAKmKGYZoYvgmKaWKLDwMDwlYGB4T8tLXEYtYRUS35BLZlPSDETGRbYMjAwsEItOECGfrygBmrwPwYGhnhqG16NZHgCtQ2vQjI8kdqG60ENponhMJAExaNgFAwAAADtqh1TMLrxOQAAAABJRU5ErkJggg==');
            }
            span.category {
                background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAMAAADXqc3KAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAC61BMVEWap6cAAACYpqaWo6OSoKCRn5+OnJyLmpqIl5eFlJSEkY9AnOY+meY8luY7lOc5kec4j+eVo6Oqtra3wcG2wcGksLCPnZ2OnZ3I0dG0v7+BkJCMmprG0NCzvr5/jo6KmJjFzs6uurqEk5OIl5eIl5eKmZmSoKCHlpbCzMzP2NjBzMzCzc3Dzc22wsKRn5+Ek5PAysqPnZ2BkJC9yMiMmpp+jY27xsaIl5d7i4u4xcWGlJR4iIi2w8OEkY90hYWzwcFhqsdQuOZRt+RRt+RRt+RygoKxv79Zw+9NsuJvf3+uvb1Zw/JLruFsfHysu7tWv/JJq+JpenqqublSuvJIp+JneHiqublOtfJFpOJpenqPn5+ot7eptrV4rcxLsfJDoeJygoJpeXlldXVpcGlKls1HrfNBneNAnOZEqfM/muM+meZBpvM9luM8luY+o/M8lOM7lOc8n/M7keQ6kec5jeQ4j+c8nO0+n+4+n+4+n+47mOs4jeb3/Pz1+vr3+/v0+fn1+/vz+fnz+Pjz+vrx+Pjx9/fv9vbw9vby9/b0+fjW39/v9/ft9fXi8fTK6PDG5/DH5/Dc7/PS3Nzt9vbu9fSz4O5q0O9n0/Jo0/Jn0vGX2Ozp8/Pr9PTQ2trr9fXs9POi2etm2Pdw4/9w4v9s3/2C0evk8PLp8vLo8vLq9PTN2Njq8vGh1+pk1Pdt3/9p2/2Cz+vm8fDO19bn8vLo8fCf1eph0fhq3P9n2f1txuqc1Oqf1eug1uuQx9zl8fHm8O6c0+pezvhm2P9m1/9l1/5h0Plezfhfzvhgzvjj7+/k7u2b0ehayfhi0/9h0/9j1P/h7u7i7eyZz+hXxfhez/9dzv9ezv/g7e3h7euXzOhTwPhZyf/h7+/i7u2Xy+lPu/hUxP9Uw/9VxP9Lt/hPv/9Qv/9Is/hLuv9Kuv9FrvhHtf9Gtf9BqvhDsf9CsP8+pvg/rf8/rP87ovg7qP87qf8/qvhCtP9BtP////9qAYayAAAAfHRSTlMAAAAAAAAAAAAAAAAAAAAAADDQ+PaxDUf34RRH+OEUR/jmT0BBOhJH+Pr4+PnuYEf4ekf4eUf4eUf4eUf4eUf4uXZ4WRFH+OQ7R/jxQ0f48EJH+PBCSPnwQjfb+vj78EIKMkE8m/BCefBCefBCefBCefBCeUJW5vf29cQsTnDbVwAAAAFiS0dE+DtjZ2YAAAGCSURBVCjPYxAUEhYBAVExBkZkwCAuUVMLApJSTKgS0jJ19SAgK8eMKiGv0NAIBE2KSsoqEKCqxgKSUNdobgGCVk0tbQjQ0dVjBUnoG7S0tXd0dHQCjWsEKWnuMmQDSRgZd/f09vWDwISJPUDQPcmEHSRhajZ5ytRp02cAwcxZs+fMmdMz15wDJGFhOW/+goWLFgPBkqXLlq9YsXKVFSdIwtpm9uo1a9eBwPoNG1evXj1/ky0XSMLOfvOWrdu2g8COnbt27969Z6+Do5OzC4Or2779Bw4eOgwER44ePAYEB48fP+HuweDpdfLU6TNnz4HAWRg47+3D4Ot34eKly1euooBr/gEMgUHXb9y8dRsNBIcwhIbduXvv/oOHKOBReARDZFR0TOzjJ6jgaVw8Q0JiUnLKs+co4MXz1DRQtHGnv3z1GgW8ysgESfBkvXn7DgW8zc4BSfDmvv+AAj5+yMsHSfAVfPqMCr4UFoEk+Iu/fvuOAr7llYAkBErLyitQQGVVNQArEzJz0pHnIAAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxNS0wNy0yNVQyMTo0OTozNiswODowMI10McMAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTAtMDYtMjBUMDA6MDA6MDArMDg6MDCHcFRIAAAATnRFWHRzb2Z0d2FyZQBJbWFnZU1hZ2ljayA2LjguOC0xMCBRMTYgeDg2XzY0IDIwMTUtMDctMTkgaHR0cDovL3d3dy5pbWFnZW1hZ2ljay5vcmcFDJw1AAAAGHRFWHRUaHVtYjo6RG9jdW1lbnQ6OlBhZ2VzADGn/7svAAAAF3RFWHRUaHVtYjo6SW1hZ2U6OkhlaWdodAAzMij0+PQAAAAWdEVYdFRodW1iOjpJbWFnZTo6V2lkdGgAMzLQWzh5AAAAGXRFWHRUaHVtYjo6TWltZXR5cGUAaW1hZ2UvcG5nP7JWTgAAABd0RVh0VGh1bWI6Ok1UaW1lADEyNzY5NjMyMDCPiM2kAAAAEXRFWHRUaHVtYjo6U2l6ZQA2MDhCQj/+WhwAAABYdEVYdFRodW1iOjpVUkkAZmlsZTovLy9ob21lL3d3d3Jvb3Qvd3d3LmVhc3lpY29uLm5ldC9jZG4taW1nLmVhc3lpY29uLmNuL3NyYy81MDQ5LzUwNDk5My5wbmc54nw0AAAAAElFTkSuQmCC');
            }
            span.project {
                background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEwAACxMBAJqcGAAAAdtJREFUSIm11MuLzWEYB/DPOeNgXGakIePSccks1GCQy0IsiAVrSSlKTUZZysq/YCUsZGMlYmFrIZNIRLOdaUpRk1xyi8Zh8bzn9Os0fucc58y33n7v7+19nu9z+T4v/4852NPoUrENgj84PJsE+/ClDftcLMYzrJ4N530YxUjmrKtTzrdhEpdQSP9nUO6E8yP4jNNYhBu4qL0+1rAVP3FSyPMRznXCcRVX8DTtj+K7JiNvNr03GE/7XnRjRwsBNsQSIctuLMUnjKHUSZLtuJD2x8Qk7+0kAVGW9Wk/LjKroiAE0DTKGMZBLMucF7EWQ3X3N+E87mFBlnUmDOJxWrfxAb9FzRemyPtQEQK4j4/J9g5u4W4eAZHuOvQnp12Yxle8T46/1dnMxwsxlBM5vms4gGsYSFHPTWRl7Mcp8fAR8r2OQ1kHeRkQZRjBbqwSMv2VMpjEKzzAW+zEEzGELWENelo1qqJRBnBVKGlMNBuWi7KN4qycqGciWClqP4GXyXhIlKlfyHQqEdaXpCjKOvUvwsFkcBlbRFMboTcFcBwnxFNSs6vPoIBd2IwNWJGiqmTuVMRMTOMH3olmvxbPyUbclOaiUQ8GRMl6hIJKac1LUVa/pZT5QzzPOvgLIMlTPTZOcVwAAAAASUVORK5CYII=');
            }
            span.folder {
                background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABhlBMVEX///+AgIBfgJZfgJZfgJZfgJZfgJZfgJZfgJZfgJZfgJZfgJZfgJZfgJZfgJZfgJZfgJZfgJZfgJZfgJZhgZfq8fXw9vv0+fzx9/tvjaFig5jH3e3G3OzC2+zQ4/Ds9Pny9/v0+Pv0+ftpiJ22zuSjwdWEoragu9iAnrPBztb////h5+uctNTK3enM4e7N4e7X5/LP4u7U5fDR5PDd6/Pb6fLT5fDY6PLQ4OqLp8V5lae/1uXA2OfI3eq81ebS4+6/1+fF2+rL3uvT5O7M3+ylvs96l7OdssCmw9ezzd+rydywzd+yzd++1uXE2eexzeC50uK0z+G81OSPqbxsi6WovsufvdCkwdOnw9WLscqMscuiwdWdvtKPtM6tyNqtydp9maxigpisxNKbuMuVtMicucyBp8CJrMWCqcKUtcukwNOkwdRlhZpmhpubt8qWs8eJqsCUscWMrMKDp7+YtciTssefu86jv9Jjg5mRr8OPrMGOrMCGpr2Nq8CJqb6QrsKZtsmauMpPbnoFAAAAE3RSTlMAAIfw/JMS2mbP5654QgzR/unEMY/lsgAAAAFiS0dEAIgFHUgAAADFSURBVBjTY2AgCJiYhYVZWBnhgEFEVExcQlIYDJiZgAJS0jKycvIKikpAIKrMxsggrKKqJgwH7BwMwuoamlpwoM3JIKwjoqunb2BoZGxiamZuwcUgbGllbWNrZ+/g6ORs7+LKzSDs5u7h6eXt4+vnHxAYFMzDIBwSGhYeERkVHRMbFx+fwMsgnJiUnJKcmpaanpGZlZ3DxyCcm5dfUFhYVFhcUlpWLszIwF9RUFlVXVNbXVdf2NAowMjAIYhwlrCAECOGZwER4ylalXDm6wAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxNS0wNy0yNVQyMTo1MDoxOCswODowMKL1uekAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTItMTEtMTFUMjE6MTM6NTUrMDg6MDB3Er/4AAAATnRFWHRzb2Z0d2FyZQBJbWFnZU1hZ2ljayA2LjguOC0xMCBRMTYgeDg2XzY0IDIwMTUtMDctMTkgaHR0cDovL3d3dy5pbWFnZW1hZ2ljay5vcmcFDJw1AAAAGHRFWHRUaHVtYjo6RG9jdW1lbnQ6OlBhZ2VzADGn/7svAAAAF3RFWHRUaHVtYjo6SW1hZ2U6OkhlaWdodAAxNh2vXm8AAAAWdEVYdFRodW1iOjpJbWFnZTo6V2lkdGgAMTblAJ7iAAAAGXRFWHRUaHVtYjo6TWltZXR5cGUAaW1hZ2UvcG5nP7JWTgAAABd0RVh0VGh1bWI6Ok1UaW1lADEzNTI2Mzk2MzUk3CjYAAAAEnRFWHRUaHVtYjo6U2l6ZQAxLjVLQkJhgJctAAAAWnRFWHRUaHVtYjo6VVJJAGZpbGU6Ly8vaG9tZS93d3dyb290L3d3dy5lYXN5aWNvbi5uZXQvY2RuLWltZy5lYXN5aWNvbi5jbi9zcmMvMTA5MjUvMTA5MjU0Ny5wbmcfneLaAAAAAElFTkSuQmCC');
            }
            span.package {
                background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAABGdBTUEAAK/INwWK6QAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACZ1BMVEX////YtE3YskvXsErWrkjZtk7YtE3XskvVrEXUqkTTp0Lat0/Ztk7YtEzRpD/Qoj3PoDvZt0/ZtU7OnTnNmjbZt0/ZtU3LlTLYtE3Jki/XskvIjy3WsEnHjSvVrUfGiijUqkTFhybTqELEhSTSpUDDgyLQoj3PoDvOnTnDhCPCgiLCgCDNmjbMmDTLlTLEhiXDhCPCgiHKkzDJkC7IjizEhSTDgyPGiyrFiSjFhybEhSTq1ZznzIjlz5L8+Ob+9uPy3a/35LLhwHLgxn737tH///b//vD77cvarVD314v54ary1pXbsmLt2aX169Lt3r7eyZXbw4nWuHDduWn115D1z3/4253646rsyoTVplH++OH5683t0pLrzITlv2/bsVbIlDv67M7/9dn/6rn+35X/1Xf/5KX73IT9+OL/89T65LDxz4b10H/10HjksUz/6bb/4Zv+1nj1vUDptT3x1ZD99uL/9Nr/89X/67331Yn1yWnptEz72o3/3Iz5xEjstjjov0jou0/w0Iz89uL/9Nf/8s7/78j/67r725LxwVb5wkjwvTvsxUfpvUXmtULmsUfuyoj/8Mn/7b7/6rP/563+2Xzvx0jqxEPovkPmtT/jqzrhp0DsxYP+++f/9t3/78H/67f/6Kv/5KT+4ZbrxkjpvUDmtD3iqTjenzLmtmvuxIPcvXf25b//9tv/7sH/5aX/45/+4ZTqwUbmtTriqjflr1btxofks3TKkErgwH387sf/8sz/6Kj+4JTnukHksUXvyorrwYLQl1PlxIL/9Mz/78Tx0ovwzorXpF/rzY/it2/IjkD///+fmXDcAAAAO3RSTlMAK6+8MRaE7/OMGgVl2+BsCUbCyE2f/qb7+/Dw8PDw8PDw+fi7wQZl2+BtChaF7/ONGyul/qwxRr7ETfEaKk4AAAABYktHRACIBR1IAAAA+UlEQVQY02NgAANGJmYWBgRgZWO3tuHg5IJyuXl4be3sHRyd+PgFQHxBIWcXVzd3D08vbx9hEQYGUTFfP/+AwKDgkNCw8IhIcQaJqOiY2Lj4hMSk5JTUtHRJBqmMzKzsnNy8rPyCwqLiEmkGmdKy8orKquqa2rr6hsYmWQa55pbWtvaOzq7unt6+/gnyDArNmRMnTZ4yddr0GTNnzZ6jyKA0d978BQsXLV6ydNnyFStXKTOorF6zdt36DRs3bd6yddv2HaoMauoaO3ft3rN33/4DBw9pamkDnaqjq3f4yNFjx0/oGxhCfWNkbHLy1GlTMyT/mltYWkFYAOcyUjk1dbrSAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE1LTA3LTI1VDIxOjUwOjI3KzA4OjAw2jLO4wAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxMC0wNC0yNlQwMDowMDowMCswODowMKBVO10AAABOdEVYdHNvZnR3YXJlAEltYWdlTWFnaWNrIDYuOC44LTEwIFExNiB4ODZfNjQgMjAxNS0wNy0xOSBodHRwOi8vd3d3LmltYWdlbWFnaWNrLm9yZwUMnDUAAAAYdEVYdFRodW1iOjpEb2N1bWVudDo6UGFnZXMAMaf/uy8AAAAXdEVYdFRodW1iOjpJbWFnZTo6SGVpZ2h0ADE2Ha9ebwAAABZ0RVh0VGh1bWI6OkltYWdlOjpXaWR0aAAxNuUAnuIAAAAZdEVYdFRodW1iOjpNaW1ldHlwZQBpbWFnZS9wbmc/slZOAAAAF3RFWHRUaHVtYjo6TVRpbWUAMTI3MjIxMTIwMAkpDe8AAAARdEVYdFRodW1iOjpTaXplADg1M0JCu0X7rgAAAFZ0RVh0VGh1bWI6OlVSSQBmaWxlOi8vL2hvbWUvd3d3cm9vdC93d3cuZWFzeWljb24ubmV0L2Nkbi1pbWcuZWFzeWljb24uY24vc3JjLzIzMC8yMzA3OS5wbmflxeC9AAAAAElFTkSuQmCC');
            }
            span.file {
                background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAnRSTlMAAHaTzTgAAAACYktHRAD/h4/MvwAAACpJREFUGNNjYGBogAEGKGj4DwFwEbjA/wZ0AagIQgvUHJgAWHBwCyADBgBRlaj0nZILPgAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxNS0wNy0yNVQyMTo0OTozNyswODowMCsDOncAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTAtMDQtMjZUMDA6MDA6MDArMDg6MDCgVTtdAAAATnRFWHRzb2Z0d2FyZQBJbWFnZU1hZ2ljayA2LjguOC0xMCBRMTYgeDg2XzY0IDIwMTUtMDctMTkgaHR0cDovL3d3dy5pbWFnZW1hZ2ljay5vcmcFDJw1AAAAGHRFWHRUaHVtYjo6RG9jdW1lbnQ6OlBhZ2VzADGn/7svAAAAF3RFWHRUaHVtYjo6SW1hZ2U6OkhlaWdodAAxNh2vXm8AAAAWdEVYdFRodW1iOjpJbWFnZTo6V2lkdGgAMTblAJ7iAAAAGXRFWHRUaHVtYjo6TWltZXR5cGUAaW1hZ2UvcG5nP7JWTgAAABd0RVh0VGh1bWI6Ok1UaW1lADEyNzIyMTEyMDAJKQ3vAAAAEXRFWHRUaHVtYjo6U2l6ZQAxMzFCQpC6Em0AAABWdEVYdFRodW1iOjpVUkkAZmlsZTovLy9ob21lL3d3d3Jvb3Qvd3d3LmVhc3lpY29uLm5ldC9jZG4taW1nLmVhc3lpY29uLmNuL3NyYy8xNDQvMTQ0MzQucG5nOEiBFgAAAABJRU5ErkJggg==');
            }
            span.method {
                background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEwAACxMBAJqcGAAAATxJREFUOI21kl0rw2EYh6+Lpfgg8tbCGCfOKKUkJS+pqeUjSUpKvglHCuVEKZTxAYwspe1xsFu29V+OdtdT98vv/j33G/RQ8uq9eg9MdQP1ddgzwFroo8BwvNHwrQLFbmQF9V1N6pn6EnpSX9VTtaF+ALNZBEtqvSUpqV9qrcNXB5YzS1CPAvQObAM5oB/YUKsRO87KnQZK6rOagF2gqN6ot8A8sBUEFaAEFACMn2+BfJDVU0pD6gVwCTSAhZTSnPoJDATuLqU0ngsjdXYD1IGhiH3T3JgtmLacEWBdfYwWyjTv4DwqmQT2ooUnYJ2/1bYN8ThANWAfGIxXVj8jdpI1RICV2HPryhpZPpoHBbRfYgV4i6EdAg/Rs8AjcBBzqQLP3aqYAJZC3/z9FdgJ3yJ/2/pXxtQr9TqIeyM/KyRgjfF1WZIAAAAASUVORK5CYII=');
            }
            span.comprehensive {
                color: rgb(127, 63, 63);
                font-weight: bold;
            }
            table>thead {
                text-align: left;
                background-color: rgb(230, 230, 230);
            }
            fieldset p, fieldset pre, fieldset ul, fieldset ol, fieldset li {
                margin: 5px 0px 5px 0px;
            }
            div.code, div.info, div.warning {
                padding: 5px;
            }
            div.code {
                background-color: rgb(230, 230, 230);
            }
            div.info {
                background-color: rgb(230, 255, 230);
            }
            div.warning {
                background-color: rgb(255, 230, 230);
            }
            div.author {
                font-size: 16px;
                font-weight: bold;
                text-align: right;
            }
            div.nowrap {
                white-space: nowrap;
            }
            table.inline {
                display: inline-table;
            }
            div.comment, span.comment {
                color: rgb(0, 127, 0);
            }
            div.tab {
                margin: 20px;
                border-bottom: solid 1px rgb(0, 0, 127);
                font-size: 18px;
                font-weight: bold;
            }
            div.tab > a, div.tab > span {
                display: inline-block;
                border: solid 1px rgb(0, 0, 127);
                border-bottom: none;
                padding: 5px;
                border-radius: 5px 5px 0px 0px;
                cursor: default;
                text-decoration: none;
            }
            div.tab > a:hover {
                background-color: rgb(230, 230,255);
            }
            div.tab > a:visited {
                color: black;
            }
            div.tab > span {
                background-color: rgb(0, 0, 127) ! important;
                color: white ! important;
            }
            div.loading {
                font-size: 20px;
                line-height: 20px;
            }
            .italic {
                font-style: italic;
            }
        </style>
        <script type="text/javascript">
            Array.prototype.indexOf = function (value) {
                var len = this.length;
                for (var i = 0; i < len; i++) {
                    if (this[i] === value) {
                        return i;
                    }
                }
                return -1;
            };
            HTMLElement.prototype.first = function (nodeName) {
                nodeName = nodeName.toUpperCase();
                for (var child = this.firstChild; child; child = child.nextSibling) {
                    if (child.nodeName === nodeName) {
                        return child;
                    }
                }
                return null;
            };
            HTMLElement.prototype.show = function (shown) {
                this.style.display = shown ? "" : "none";
            };
            HTMLElement.prototype.addClass = function (className) {
                var value = this.getAttribute("class");
                var arr = value ? value.split(/\s+/) : [];
                for (var i = arr.length - 1; i >= 0; i--) {
                    if (arr[i] === className) {
                        break;
                    }
                }
                arr.push(className);
                this.setAttribute("class", arr.join(' '));
            };
            HTMLElement.prototype.removeClass = function (className) {
                var value = this.getAttribute("class");
                var arr = value ? value.split(/\s+/) : [];
                for (var i = arr.length - 1; i >= 0; i--) {
                    if (arr[i] === className) {
                        arr.splice(i, 1);
                        this.setAttribute("class", arr.join(' '));
                        break;
                    }
                }
            };
            HTMLElement.prototype.hasClass = function (className) {
                var value = this.getAttribute("class");
                var arr = value ? value.split(/\s+/) : [];
                for (var i = arr.length - 1; i >= 0; i--) {
                    if (arr[i] === className) {
                        return true;
                    }
                }
                return false;
            };
            HTMLDocument.prototype.on = HTMLElement.prototype.on = function (eventName, eventHandler) {
                if (this.addEventListener) {
                    this.addEventListener(eventName, eventHandler, false);
                } else if (this.attachEvent) {
                    var that = this;
                    this.attachEvent("on" + eventName, function () {
                        eventHandler.call(that, window.event);
                    });
                } else {
                    if (this.$eventHandlers) {
                        this.$eventHandlers.push(eventHandler);
                    } else {
                        this.$eventHandlers = [eventHandler];
                        var that = this;
                        this["on" + eventName] = function (e) {
                            var arr = this.$eventHandlers;
                            var len = arr.length;
                            for (var i = 0; i < len; i++) {
                                arr[i].call(that, e || window.event);
                            }
                        };
                    }
                }
            };
            Node.prototype.ancestor = function (nodeName, filter) {
                nodeName = nodeName.toUpperCase();
                for (var node = this; node; node = node.parentNode) {
                    if (node.nodeName === nodeName) {
                        if (arguments.length < 2 || filter(node)) {
                            return node;
                        }
                    }
                }
                return null;
            };
            (function () {
                var ICON_CLASSES = ["category", "project", "folder", "package", "file", "method"];
                var GITHUB = "https://github.com/babyfish-ct/babyfish/tree/babyfish2";
                var SIMPLE_VAR_MAP = {
                    ":github": GITHUB,
                    ":r-main": "src/main/resources",
                    ":r-test": "src/test/resources",
                    ":main": "src/main/java",
                    ":test": "src/test/java",
                    ":jee-api": "https://docs.oracle.com/javaee/7/api"
                };
                var CONTEXT_VAR_MAP = {
                    ":project": "$project",
                    "!project": "$projectPath",
                    ":folder": "$folder",
                    "!folder": "$folderPath",
                    ":package": "$package",
                    "!package": "$packagePath"
                };
                document.on("readystatechange", function () {
                    if (document.readyState != "complete") {
                        return;
                    }
                    var errors = processHyperLinks();
                    document.getElementById("expandDocumentButton").on("click", function () {
                        setDocumentExpaneded(true);
                    });
                    document.getElementById("collapseDocumentButton").on("click", function () {
                        setDocumentExpaneded(false);
                    });
                    document.getElementById("expandCatalogButton").on("click", function () {
                        setCatalogExpanded(true);
                    });
                    document.getElementById("collapseCatalogButton").on("click", function () {
                        setCatalogExpanded(false);
                    });
                    var fieldsets = document.getElementsByTagName("FIELDSET");
                    for (var i = 0; i < fieldsets.length; i++) {
                        determineChapterTree(fieldsets[i]);
                    }
                    buildChapters(fieldsets);
                    addChapterLinks(fieldsets);
                    trimPreAndCode();
                    createCatalog(fieldsets);
                    initSplitter();
                    fixBugOfIEOrEdge();
                    if (errors.length) {
                        throw new Error(errors.join("\n"));
                    }
                });
                var processHyperLinks = function () {

                    var fieldsets = document.getElementsByTagName("FIELDSET");
                    for (var i = fieldsets.length - 1; i >= 0; i--) {
                        determinePath(fieldsets[i], null);
                    }
                    var links = document.getElementsByTagName("A");
                    var errors = [];
                    for (var i = links.length - 1; i >= 0; i--) {
                        var link = links[i];
                        var id = link.getAttribute("id");
                        if (id) {
                            link.setAttribute("name", id);
                        }
                        if (link.innerHTML.trim() === "") {
                            errors.push('Empty hyperlink whose id is "' + id + '"');
                        }
                    }
                    for (var i = links.length - 1; i >= 0; i--) {
                        var link = links[i];
                        var href = link.getAttribute("href");
                        if (href) {
                            if (href.charAt(0) === "#") {
                                link.addClass("hash-link");
                                var target = document.getElementById(href.substring(1));
                                if (!target || target.nodeName !== "A") {
                                    errors.push('Invalid hash href "' + href + '"');
                                }
                            } else {
                                var newHref = href;
                                for (var contextVarName in CONTEXT_VAR_MAP) {
                                    if (newHref.indexOf(contextVarName) != -1) {
                                        var field = CONTEXT_VAR_MAP[contextVarName];
                                        var fieldset = link.ancestor("fieldset", function (fs) {
                                            return fs[field];
                                        });
                                        if (!fieldset) {
                                            errors.push(
                                                'Cannot resolve "' +
                                                contextVarName +
                                                '" of <a href="' +
                                                href +
                                                '"/>'
                                            );
                                        } else {
                                            newHref = newHref.replace(contextVarName, fieldset[field]);
                                        }
                                    }
                                }
                                for (var simpleVarName in SIMPLE_VAR_MAP) {
                                    if (newHref.indexOf(simpleVarName) != -1) {
                                        var value = SIMPLE_VAR_MAP[simpleVarName];
                                        newHref = newHref.replace(simpleVarName, value);
                                    }
                                }
                                var typeIndex = newHref.indexOf(":type");
                                if (typeIndex != -1) {
                                    var ext = newHref.indexOf(GITHUB) == 0 ? ".java" : ".html";
                                    var typeName = getText(link).trim();
                                    if (typeName.charAt(0) == '@') {
                                        typeName = typeName.substring(1);
                                    }
                                    var index = typeName.indexOf('<');
                                    if (index != -1) {
                                        typeName = typeName.substring(0, index);
                                    }
                                    index = typeName.lastIndexOf('.');
                                    if (index == -1) {
                                        var fieldset = link.ancestor("fieldset", function (fs) {
                                            return fs.$package;
                                        });
                                        if (!fieldset) {
                                            errors.push(
                                                'The href "' +
                                                href +
                                                '" contains ":type", but its inner text does not support package, ' +
                                                'so it must be declared under <fieldset class="tree-node package"/>'
                                            );
                                        }
                                        newHref = newHref.replace(":type", typeName + ext);
                                    } else {
                                        var packageName = typeName.substring(0, index);
                                        if (newHref.substring(typeIndex - packageName.length, typeIndex) == packageName) {
                                            newHref = newHref.replace(":type", typeName + ext);
                                        } else {
                                            newHref = newHref.replace(":type", typeName.split('.').join('/') + ext);
                                        }
                                    }
                                }
                                if (href !== newHref) {
                                    link.setAttribute("target", "_blank");
                                    link.setAttribute("href", newHref);
                                } else if (href.indexOf("http://") == 0 || href.indexOf("https://") == 0) {
                                    link.setAttribute("target", "_blank");
                                }
                            }
                        }
                    }
                    document.getElementById("documentDiv").on("click", function (e) {
                        if (e.target.nodeName !== "A") {
                            return;
                        }
                        var href = e.target.getAttribute("href");
                        if (href && href.charAt(0) === '#') {
                            e.preventDefault();
                            smartHashLink(href);
                        }
                    });
                    return errors;
                };
                var determinePath = function (fieldset, parentFieldset) {
                    if (fieldset === parentFieldset || !fieldset.hasClass("tree-node")) {
                        return;
                    }
                    var cc = null;
                    if (fieldset.hasClass("project")) {
                        cc = "project";
                    } else if (fieldset.hasClass("folder")) {
                        cc = "folder";
                    } else if (fieldset.hasClass("package")) {
                        cc = "package"
                    } else if (fieldset.hasClass("file")) {
                        cc = "file";
                    }
                    if (!cc) {
                        return;
                    }
                    var actualParentFieldset = fieldset.parentNode.ancestor("fieldset", function (fs) {
                        return fs.hasClass("tree-node");
                    });
                    if (!parentFieldset) {
                        if (!actualParentFieldset || !actualParentFieldset.hasClass("category")) {
                            return;
                        }
                    } else if (parentFieldset != actualParentFieldset) {
                        return;
                    }
                    var legend = fieldset.first("legend");
                    var text = getText(legend).trim();
                    if (cc != "file") {
                        text = text.split('.').join('/')
                    }
                    fieldset['$' + cc] = text;
                    var path =
                        (parentFieldset ? parentFieldset.$$path : GITHUB + "/demo") +
                        '/' +
                        text;
                    if (cc != "file") {
                        fieldset['$' + cc + "Path"] = fieldset.$$path = path;
                    }
                    var a = legend.first("a");
                    if (!a) {
                        a = document.createElement("A");
                        while (legend.firstChild) {
                            a.appendChild(legend.firstChild);
                        }
                        legend.appendChild(a);
                    }
                    if (!a.hasAttribute("href")) {
                        a.setAttribute("href", path);
                    }
                    var fieldsets = fieldset.getElementsByTagName("FIELDSET");
                    for (var i = fieldsets.length - 1; i >= 0; i--) {
                        determinePath(fieldsets[i], fieldset);
                    }
                };
                var determineChapterTree = function (fieldset) {
                    if (fieldset.$chapterNumber) {
                        return fieldset.$chapterNumber;
                    }
                    if (!isTreeNodeFieldset(fieldset)) {
                        return null;
                    }
                    var chapterNumber = "";
                    var prev = prevFieldset(fieldset);
                    if (prev) {
                        prev.$next = fieldset;
                        chapterNumber = determineChapterTree(prev);
                        var index = chapterNumber.lastIndexOf('.');
                        if (index != -1) {
                            chapterNumber =
                                chapterNumber.substring(0, index + 1) +
                                (parseInt(chapterNumber.substring(index + 1)) + 1);
                        } else {
                            chapterNumber = "" + (parseInt(chapterNumber) + 1);
                        }
                    } else {
                        var parent = parentFieldset(fieldset);
                        if (parent) {
                            parent.$first = fieldset;
                            chapterNumber = determineChapterTree(parent) + ".1";
                        } else {
                            chapterNumber = "1";
                        }
                    }
                    fieldset.$chapterNumber = chapterNumber;
                    return chapterNumber;
                };
                var buildChapters = function (fieldsets) {
                    for (var i = fieldsets.length - 1; i >= 0; i--) {
                        var fieldset = fieldsets[i];
                        if (!fieldset.$chapterNumber) {
                            continue;
                        }
                        var legend = fieldset.first("legend");
                        fieldset.$title = getText(legend);
                        var classes = fieldset.getAttribute("class") || fieldset.className;
                        var contentDiv = document.createElement("DIV");
                        var silbing = legend.nextSibling;
                        while (silbing) {
                            var nextSibling = silbing.nextSibling;
                            contentDiv.appendChild(silbing);
                            silbing = nextSibling;
                        }
                        fieldset.appendChild(contentDiv);
                        for (var ii = ICON_CLASSES.length - 1; ii >= 0; ii--) {
                            if (classes.indexOf(ICON_CLASSES[ii]) != -1) {
                                fieldset.$levelClass = ICON_CLASSES[ii];
                                insertIcon(legend, ICON_CLASSES[ii]);
                                break;
                            }
                        }
                        var span = document.createElement("SPAN");
                        span.addClass("chapter-number");
                        span.className = "chapter-number";
                        span.appendChild(document.createTextNode(' ' + fieldset.$chapterNumber + ' ')),
                        legend.insertBefore(span, legend.firstChild);
                        var expanded = insertIcon(legend, "expanded");
                        var collapsed = insertIcon(legend, "collapsed");
                        collapsed.style.display = "none";
                        fieldset.$expanded = expanded;
                        fieldset.$collapsed = collapsed;
                        expanded.$fieldset = fieldset;
                        collapsed.$fieldset = fieldset;
                        fieldset.$legend = legend;
                        fieldset.$content = contentDiv;
                        expanded.on("click", function () {
                            setExpanded(this.$fieldset, false);
                        });
                        collapsed.on("click", function () {
                            setExpanded(this.$fieldset, true);
                        });
                    }
                };
                var addChapterLinks = function (fieldsets) {
                    for (var i = fieldsets.length - 1; i >= 0; i--) {
                        var link = document.createElement("A");
                        var legend = fieldsets[i].$legend;
                        link.setAttribute("id", "chapter_" + fieldsets[i].$chapterNumber);
                        link.setAttribute("name", "chapter_" + fieldsets[i].$chapterNumber);
                        var childNode = legend.firstChild;
                        while (childNode) {
                            var nextChild = childNode.nextSibling;
                            var childNodeClass = childNode.nodeType == 1 ? childNode.getAttribute("class") : null;
                            if (childNodeClass !== "expanded" && childNodeClass !== "collapsed") {
                                link.appendChild(childNode);
                            }
                            childNode = nextChild;
                        }
                        legend.appendChild(link);
                    }
                };
                var createCatalog = function (fieldsets) {
                    var div = document.createElement("DIV");
                    div.addClass("catalog");
                    for (var i = 0; i < fieldsets.length; i++) {
                        var fieldset = fieldsets[i];
                        if (fieldset.$chapterNumber.indexOf('.') == -1) {
                            var itemDiv = createCatalogItem(fieldset);
                            if (itemDiv) {
                                div.appendChild(itemDiv);
                            }
                        }
                    }
                    var catalogDiv = document.getElementById("catalogDiv");
                    while (catalogDiv.firstChild) {
                        catalogDiv.removeChild(catalogDiv.firstChild);
                    }
                    catalogDiv.appendChild(div);
                    catalogDiv.on("click", function (e) {
                        var link = null;
                        for (var node = e.target; node != this; node = node.parentNode) {
                            if (node.nodeName === "A") {
                                link = node;
                                break;
                            }
                        }
                        if (link) {
                            var href = link.getAttribute("href");
                            if (href.charAt(0) === '#') {
                                e.preventDefault();
                                if (window.$selectedLink) {
                                    window.$selectedLink.removeClass("selected");
                                }
                                window.$selectedLink = link;
                                link.addClass("selected");
                                smartHashLink(href, true);
                            }
                        } else if (e.target.nodeName == "SPAN") {
                            var item = e.target.parentNode;
                            var expanded = item.$expanded === e.target;
                            var collapsed = item.$collapsed === e.target;
                            if (expanded || collapsed) {
                                item.$expanded.style.display = expanded ? "none" : "";
                                item.$collapsed.style.display = collapsed ? "none" : "";
                                item.$sub.style.display = expanded ? "none" : "";
                            }
                        }
                    });
                };
                var initSplitter = function () {
                    var splitter = document.getElementById("splitter");
                    var splitterLeftDiv = document.getElementById("splitterLeftDiv");
                    var splitterDrag = document.getElementById("splitterDrag");
                    var splitterDragging = document.getElementById("splitterDragging");
                    var splitterDargButton = document.getElementById("splitterDragButton");
                    var splitterDragArrow = document.getElementById("splitterDragArrow");
                    var dragging = null;
                    var leftDraggingFilter = document.getElementById("leftDraggingFilter");
                    var rightDraggingFilter = document.getElementById("rightDraggingFilter");
                    var catalogBar = document.getElementById("catalogBar");
                    splitterDrag.on("mousedown", function (e) {
                        if (e.target.getAttribute("class") !== "drag") {
                            return;
                        }
                        dragging = { x: e.pageX, width: splitterLeftDiv.offsetWidth };
                        splitterDragging.style.left = splitterLeftDiv.offsetWidth + "px";
                        splitterDragging.style.display = "block";
                        leftDraggingFilter.style.display = "block";
                        rightDraggingFilter.style.display = "block";
                        e.preventDefault();
                    });
                    splitter.on("mousemove", function (e) {
                        if (!dragging) {
                            return;
                        }
                        var width = newWidth(e);
                        splitterDragging.style.left = width + "px";
                        e.preventDefault();
                    });
                    var releaseHandler = function (e) {
                        if (!dragging) {
                            return;
                        }
                        var width = newWidth(e);
                        dragging = null;
                        splitterDragging.style.display = "none";
                        leftDraggingFilter.style.display = "none";
                        rightDraggingFilter.style.display = "none";
                        var hide = width < 30;
                        if (!hide) {
                            splitterLeftDiv.style.width = width + "px";
                        }
                        splitterLeftDiv.style.display = hide ? "none" : "";
                        splitterDragArrow.innerHTML = hide ? "&#9658" : "&#9668";
                        catalogBar.style.display = hide ? "none" : "";
                    };
                    var newWidth = function (e) {
                        var width = dragging.width + e.pageX - dragging.x;
                        width = Math.min(width, splitter.offsetWidth - splitterDrag.offsetWidth - 200);
                        width = Math.max(width, 0);
                        return width;
                    };
                    splitter.on("mouseup", releaseHandler);
                    splitter.on("mouseleave", releaseHandler);
                    splitterDargButton.on("click", function () {
                        var hide = splitterLeftDiv.style.display != "none";
                        splitterLeftDiv.style.display = hide ? "none" : "";
                        splitterDragArrow.innerHTML = hide ? "&#9658" : "&#9668";
                        catalogBar.style.display = hide ? "none" : "";
                    });
                };
                var createCatalogItem = function (fieldset) {
                    if (!fieldset.$legend) {
                        return null;
                    }
                    var itemDiv = document.createElement("DIV");
                    itemDiv.addClass(fieldset.$levelClass);
                    var a = document.createElement("A");
                    a.setAttribute("href", "#chapter_" + fieldset.$chapterNumber);
                    var chapter = document.createElement("SPAN");
                    chapter.addClass("chapter-number");
                    chapter.appendChild(document.createTextNode(fieldset.$chapterNumber + ' '));
                    a.appendChild(chapter);
                    var span = document.createElement("SPAN");
                    span.addClass(fieldset.$levelClass);
                    a.appendChild(span);
                    a.appendChild(document.createTextNode(fieldset.$title));
                    itemDiv.appendChild(a);
                    if (fieldset.$first) {
                        var subDiv = document.createElement("DIV");
                        subDiv.addClass("sub-catalog");
                        for (var child = fieldset.$first; child; child = child.$next) {
                            var subItemDiv = createCatalogItem(child);
                            if (subItemDiv) {
                                subDiv.appendChild(subItemDiv);
                            }
                        }
                        itemDiv.appendChild(subDiv);
                        itemDiv.$sub = subDiv;
                        itemDiv.$expanded = insertIcon(itemDiv, "expanded");
                        itemDiv.$collapsed = insertIcon(itemDiv, "collapsed");
                        itemDiv.$collapsed.style.display = "none";
                    } else {
                        insertIcon(itemDiv, "collapsed").style.visibility = "hidden";
                    }
                    return itemDiv;
                };
                var parentFieldset = function (fieldset) {
                    for (var parentNode = fieldset.parentNode; parentNode; parentNode = parentNode.parentNode) {
                        if (isTreeNodeFieldset(parentNode)) {
                            return parentNode;
                        }
                    }
                    return null;
                };
                var prevFieldset = function (fieldset) {
                    for (var previousSibling = fieldset.previousSibling; previousSibling; previousSibling = previousSibling.previousSibling) {
                        if (isTreeNodeFieldset(previousSibling)) {
                            return previousSibling;
                        }
                    }
                    return null;
                };
                var isTreeNodeFieldset = function (fieldset) {
                    if (fieldset.nodeName !== "FIELDSET") {
                        return false;
                    }
                    var classes = fieldset.getAttribute("class") || fieldset.className;
                    if (!classes) {
                        return false;
                    }
                    classes = classes.split(/\s+/);
                    if (classes.indexOf("tree-node") == -1) {
                        return false;
                    }
                    var legend = fieldset.first("legend");
                    if (!legend) {
                        return false;
                    }
                    return true;
                };
                var getText = function (node) {
                    var textRef = [""];
                    collectText(node, textRef);
                    return textRef[0];
                };
                var collectText = function (node, outputRef) {
                    for (var child = node.firstChild; child; child = child.nextSibling) {
                        if (child.nodeType == 3) {
                            outputRef[0] += child.nodeValue;
                        } else if (child.nodeType == 1) {
                            collectText(child, outputRef);
                        }
                    }
                };
                var setExpanded = function (fieldset, expanded) {
                    fieldset.$expanded.show(expanded);
                    fieldset.$collapsed.show(!expanded);
                    fieldset.$content.show(expanded);
                };
                var insertIcon = function (item, iconClass) {
                    var iconSpan = document.createElement("SPAN");
                    iconSpan.addClass(iconClass);
                    item.insertBefore(iconSpan, item.firstChild);
                    return iconSpan;
                }
                var setDocumentExpaneded = function (allExpanded) {
                    var fieldsets = document.getElementsByTagName("FIELDSET");
                    for (var i = fieldsets.length - 1; i >= 0; i--) {
                        var fieldset = fieldsets[i];
                        var classes = fieldset.getAttribute("class") || fieldset.className;
                        if (!classes) {
                            continue;
                        }
                        classes = classes.split(/\s+/);
                        if (classes.indexOf("tree-node") != -1) {
                            setExpanded(fieldset, allExpanded);
                        }
                    }
                };
                var setCatalogExpanded = function (allExpanded) {
                    var catalogDiv = document.getElementById("catalogDiv");
                    var divs = catalogDiv.getElementsByTagName("DIV");
                    for (var i = divs.length - 1; i >= 0; i--) {
                        var div = divs[i];
                        if (div.$sub) {
                            div.$sub.style.display = allExpanded ? "" : "none";
                            div.$expanded.style.display = allExpanded ? "" : "none";
                            div.$collapsed.style.display = allExpanded ? "none" : "";
                        }
                    }
                }
                var trimPreAndCode = function () {
                    var pres = document.getElementsByTagName("PRE");
                    var codes = document.getElementsByTagName("CODE");
                    for (var i = pres.length - 1; i >= 0; i--) {
                        trim(pres[i]);
                    }
                    for (var i = codes.length - 1; i >= 0; i--) {
                        trim(codes[i]);
                    }
                };
                var trim = function (element) {
                    var child = element.firstChild;
                    while (child) {
                        var nextChild = child.nextSibling;
                        if (child.nodeType == 3) {
                            var nodeValue = child.nodeValue;
                            var trimedValue = nodeValue.trim();
                            if (trimedValue.length != nodeValue.length) {
                                element.removeChild(child);
                                element.insertBefore(document.createTextNode(trimedValue), nextChild);
                            }
                        }
                        child = nextChild;
                    }
                };
                var smartHashLink = function (href, fromCatalog) {
                    if (href.charAt(0) !== '#') {
                        return;
                    }
                    var hrefTarget = document.getElementById(href.substring(1));
                    if (fromCatalog) {
                        if (window.$selectedLinkTarget) {
                            window.$selectedLinkTarget.removeClass("selected");
                        }
                        (window.$selectedLinkTarget = hrefTarget).addClass("selected");
                    } else {
                        if (window.$softSelectedLinkTarget) {
                            window.$softSelectedLinkTarget.removeClass("soft-selected");
                        }
                        (window.$softSelectedLinkTarget = hrefTarget).addClass("soft-selected");
                    }
                    for (var targetNode = hrefTarget; targetNode; targetNode = targetNode.parentNode) {
                        if (targetNode.$chapterNumber) {
                            setExpanded(targetNode, true);
                        }
                    }
                    setTimeout(function () {
                        window.location.hash = "";
                        setTimeout(function () {
                            window.location.hash = href;
                        }, 0);
                    }, 0);
                };

                var fixBugOfIEOrEdge = function () {
                    var fillDiv = document.getElementById("fillDiv");
                    var topDiv = document.getElementById("topDiv");
                    var splitter = document.getElementById("splitter");
                    if (topDiv.offsetHeight + splitter.offsetHeight > fillDiv.offsetHeight) {
                        var handler = function () {
                            splitter.style.height = (fillDiv.offsetHeight - topDiv.offsetHeight) + "px";
                        };
                        window.onresize = handler;
                        handler();
                    }
                };
            })();
        </script>
    </head>
    <body>
        <div id="fillDiv" class="fill v-splitter">
            <div id="topDiv" class="top">
                <div class="title-bar">
                    <div id="catalogBar" class="nowrap">
                        <button id="expandCatalogButton" class="large large-group-start">
                            展开目录
                        </button><button id="collapseCatalogButton" class="large large-group-end">
                            折叠目录
                        </button>
                    </div>
                    <div class="title">Demo Guide(中文)</div>
                    <div class="nowrap">
                        <button id="expandDocumentButton" class="large large-group-start">
                            展开文档
                        </button><button id="collapseDocumentButton" class="large large-group-end">
                            折叠文档
                        </button>
                    </div>
                </div>
                <div class="tab">
                    <a href="./tutorial.html">Tutorial(English)</a>
                    <a href="./tutorial_zh_CN.html">Tutorial(Chinese)</a>
                    <a href="./demo-guide.html">Demo Guide(English)</a>
                    <span>Demo Guide(Chinese)</span>
                </div>
            </div>
            <div id="splitter" class="bottom h-splitter">
                <div id="splitterLeftDiv" class="left">
                    <div id="leftDraggingFilter" class="no-pointer-events"></div>
                    <div id="catalogDiv">
                        <div class="loading">
                            正在生成目录...
                        </div>
                    </div>
                </div>
                <div id="splitterDrag" class="drag">
                    <div id="splitterDragButton" class="button">
                        <div id="splitterDragArrow" class="arrow">&#9668;</div>
                    </div>
                </div>
                <div id="documentDiv" class="right document">
                    <div id="rightDraggingFilter" class="no-pointer-events"></div>
                    <div class="main">
                        <p>这个示例向导能</p>
                        <ul>
                            <li>对每一个例子给出简要阐述</li>
                            <li>提供一种学习顺序的建议</li>
                        </ul>
                    </div>
                    <div class="not-main">
                        Babyfish提供了很多个示例演示工程，大多数均为对框架的单个功能点逐个进行演示，
                        但是如下三个提供的是相对综合性的演示：
                        <a href="#babyfishdemo-om4java-dom">babyfishdemo-om4java-dom</a>，
                        <a href="#babyfishdemo-spring">babyfishdemo-spring</a>
                        and 
                        <a href="#babyfishdemo-war3shop">babyfishdemo-war3shop</a>.
                    </div>
                    <fieldset class="tree-node category">
                        <legend>Java部分演示</legend>
                        <fieldset class="tree-node project">
                            <legend>babyfishdemo-foundation</legend>
                            这个工程演示BabyFish的四个最基础的功能。
                            <ul>
                                <li>强类型国际化</li>
                                <li>.NET风格事件通知机制：委托</li>
                                <li>对象相等性实现</li>
                                <li>对象图遍历</li>
                            </ul>
                            <div class="info">
                                其中，“强类型国际化”和“.NET风格事件通知机制：委托”两个功能需要编译时字节代码增强。
                                请参见<a href="!project/pom.xml">pom.xml</a>文件中的Maven插件配置：
                                <div class="code">
                                    <pre>&lt;plugin>
  &lt;groupId>org.babyfish&lt;/groupId&gt;
  &lt;artifactId&gt;babyfish-instrument-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;${babyfish.version}&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;goals&gt;
        &lt;!--如果产品代码也使用相关功能时使用--&gt;
        &lt;goal&gt;instrument&lt;/goal&gt;
        &lt;!--如果测试代码也使用相关功能时使用--&gt;
        &lt;goal&gt;instrument-test&lt;/goal&gt;
      &lt;/goals&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.babyfish&lt;/groupId&gt;
      &lt;artifactId&gt;babyfish-model-tool&lt;/artifactId&gt;
      &lt;version&gt;${babyfish.version}&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/plugin&gt;</pre>
                                </div>
                            </div>
                            <fieldset class="tree-node folder">
                                <legend>src/test/java</legend>
                                <fieldset class="tree-node package">
                                    <legend>org.babyfishdemo.foundation.typedi18n</legend>
                                    在传统的Java开发中，你会如此实现国际化功能：
                                    <ul>
                                        <li>
                                            先创建一些包含国际化消息的资源文件，比如 
                                            resourceName.properties，
                                            resourceName_en.properties，
                                            resourceName_zh_CN.properties，
                                            resourceName_fr_FR.properties。
                                        </li>
                                        <li>
                                            每一个资源文件都包含一些键值对，当然，不同资源文件中的键是相同的，
                                            而各文件中的值是由不同国家的语言书写。作为一种可选行为，值中还可以包含一些
                                            形如 {0}，{1}，{2} ...的参数。
                                        </li>
                                        <li>
                                            使用静态方法java.util.ResourceBundle.getBundle()，可以得到一个资源对象，
                                            当然，你可以决定语言（locale）是自动选择还是手动选择。
                                            然后调用该对象的getString方法，其参数采用资源文件中定义的某个键。
                                            最后，如果获取到的值中包含参数，开发人员有职责替换它们。
                                        </li>
                                    </ul>
                                    和脚本语言一样，这个方案是一个弱类型解决方案，开发人员很难避免拼写错误，比如
                                    <ul>
                                        <li>调用ResourceBundle.getBundle时传入了错误的资源名。</li>
                                        <li>调用ResourceBundle.getString时传入了错误的键名。</li>
                                        <li>如果获取到的值包含参数，有多少个参数需要被替换处理也没有刚性约束，容易搞错。</li>
                                    </ul>
                                    太多弱类型的代码，导致代码在重构时也容易出错。
                                    <div>
                                        此包下的例子演示如何解决这一系列问题。
                                    </div>
                                    <fieldset class="tree-node file">
                                        <legend>AnnualLeaveRequestTest.java</legend>
                                        在项目产品代码目录<a href="!project/:main">src/main/ava</a>下，
                                        <a href="!project/:main/:type">org.babyfishdemo.foundation.typedi18n.AnnualLeaveRequest</a>
                                        类支持很多静态的，native的，被注解
                                        <a href=":github/src/babyfish-instrument/:main/:type">@org.babyfish.lang.I18N</a>
                                        修饰的方法。
                                        <ul>
                                            <li>
                                                这些方法的名字和资源文件
                                                <a href="!project/:r-main/:package/AnnualLeaveRequest.properties">org/babyfishdemo/foundation/typedi18n/AnnualLeaveRequest.properties</a>
                                                中的键对应。
                                            </li>
                                            <li>
                                                任何一个方法的参数数量和资源
                                                <a href="!project/:r-main/:package/AnnualLeaveRequest.properties">org/babyfishdemo/foundation/typedi18n/AnnualLeaveRequest.properties</a>
                                                中对应值的参数数量匹配。
                                            </li>
                                            <li>如果资源中某个值具备参数，那么{0}是必须的。</li>
                                            <li>如果资源中某个值具备参数，那么所有参数必须是连续的（例如： {0}{1}{2}{1}{0}是合法的，但{0}{2}是非法的）。</li>
                                        </ul>
                                        <p>
                                            所有这些限制在编译时得到验证，如果违反，将会得到编译错误;
                                            如果正确，<a href="!project/:main/:type">org.babyfishdemo.foundation.typedi18n.AnnualLeaveRequest</a>的字节码在编译时会被自动修改，
                                            所有国际化相关的方法的native标志会被清除，且其方法内部会自动增加基于java.util.ResourceBundle实现的功能性逻辑。
                                        </p>
                                        <p>
                                            为了便于简单演示，本例子仅仅有一个资源文件<a href="!project/:r-main/:package/AnnualLeaveRequest.properties">org/babyfishdemo/foundation/typedi18n/AnnualLeaveRequest.properties</a>，
                                            事实上，你可以添加其他资源文件，如AnnualLeaveRequest_zh_CN.properties。
                                        </p>
                                    </fieldset>
                                </fieldset>
                                <fieldset class="tree-node package">
                                    <legend>org.babyfishdemo.foundation.delegate</legend>
                                    此包下的所有例子演示.NET风格的事件机制：委托和事件。
                                    <fieldset class="tree-node file">
                                        <legend>BookTest.java</legend>
                                        在项目产品代码目录<a href="!project/:main">src/main/java</a>下，<a href="!project/:main/:type">org.babyfishdemo.foundation.delegate.Book</a>类
                                        定义一个需要事件通知。
                                        <div class="warning">
                                            在传统的Java Bean规范中，支持事件通知的类必须使用一个私有的 
                                            java.util.List列表以保持所有的事件监听器；
                                            并且要提供“addXXXListener”和“removeXXXListener”方法来修改它，
                                            在需要触发事件的时候，使用迭代器循环遍历这个列表对所有监听器逐个调用，
                                            遗憾的是，如果用户在事件监听器内部又调用了上述的addXXXListener”或“removeXXXListener”方法，
                                            整个循环会因java.util.ConcurrentModificationException异常而终止。
                                        </div>
                                        本例子演示如何使用<a href=":github/src/babyfish-common/:main/:type">@org.babyfish.lang.Delegate</a>解决此问题。
                                    </fieldset>
                                    <div class="info">
                                        例外，此功能也提供C++解决方案。请参考<a href=":github/c++">c++</a>。
                                    </div>
                                </fieldset>
                                <fieldset class="tree-node package">
                                    <legend>org.babyfishdemo.foundation.equality</legend>
                                    <p>
                                    此包下例子演示如何使用<a href=":github/src/babyfish-common/:main/:type">org.babyfish.lang.Equality</a>。
                                    </p>
                                    <p>
                                        方法boolean Oject.equals(Object)往往难以完美地实现，有两种经典的实现方法。
                                    </p>
                                    <ul>
                                        <li>
                                            第一种经典实现，过于严格：
                                            <div class="code">
                                                <pre><code>
        public boolean equals(Object o) {
            if (o == null || 
                o.getClass() != this.getClass()) {
                return false;
            }
            ... ...
        }
                                                        </code></pre>
                                            </div>
                                        </li>
                                        <li>
                                            第二种经典实现，过于宽松：
                                            <div class="code">
                                                <pre><code>
        public boolean equals(Object o) {
            if (!(o instanceof &lt;&lt;ThisClass&gt;&gt;)) {
                return false;
            }
            ... ...
        }
                                                        </code></pre>
                                            </div>
                                        </li>
                                    </ul>
                                    本例子演示两种经典的实现方法各自有什么问题，以及如何解决。
                                </fieldset>
                                <fieldset class="tree-node package">
                                    <legend>org.babyfishdemo.foundation.traveler</legend>
                                    此包的例子演示如何使用<a href=":github/src/babyfish-util/:main/:type">org.babyfish.util.GraphTraveler&lt;T&gt;</a>
                                    对对象图进行深度优先遍历和广度优先遍历。
                                    <fieldset class="tree-node file">
                                        <legend>TreeTravelerTest.java</legend>
                                        <fieldset class="tree-node method">
                                            <legend>testDepthFirst</legend>
                                            此测试方法演示基于树的进行深度优先遍历。
                                        </fieldset>
                                        <fieldset class="tree-node method">
                                            <legend>testBreadthFirst</legend>
                                            此测试方法演示基于树的进行广度优先遍历。
                                        </fieldset>
                                        <fieldset class="tree-node method">
                                            <legend>testStopTravelNeighborNodes</legend>
                                            此测试方法演示如何终止对邻居节点的遍历。
                                        </fieldset>
                                        <fieldset class="tree-node method">
                                            <legend>testStopTravelSiblingNodes</legend>
                                            此测试方法演示如何终止对当前节点的后续兄弟节点的遍历。
                                        </fieldset>
                                        <fieldset class="tree-node method">
                                            <legend>testStopTravel</legend>
                                            此测试方法演示如何终止终止整个遍历。
                                        </fieldset>
                                        <fieldset class="tree-node method">
                                            <legend>testBadStopping</legend>
                                            此测试方法演示终止行为只能在邻居节点遍历之前被使用；
                                            否则，会引发java.lang.UnsupportedOperationException异常。
                                        </fieldset>
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend>Style1GraphTravelerTest.java</legend>
                                        此类演示如何通过记忆已经遍历过的节点的方式，对具备环形结构的对象图进行遍历。
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend>Style2GraphTravelerTest.java</legend>
                                        此类演示通过比对每个节点的context id和当前遍历上下文id的方式，对具备环形结构的对象图进行遍历。
                                    </fieldset>
                                </fieldset>
                            </fieldset>
                        </fieldset>
                        <fieldset class="tree-node project">
                            <legend>babyfishdemo-xcollection</legend>
                            BabyFish支持X(Extension)集合框架，它扩展了Java集合框架的标准接口并给出了一整套全新的实现。
                            <fieldset class="tree-node folder">
                                <legend>src/test/java</legend>
                                <fieldset class="tree-node package">
                                    <legend>org.babyfishdemo.xcollection.entry</legend>
                                    <fieldset class="tree-node file">
                                        <legend>AliveTest.java</legend>
                                        此测试用例演示
                                        <a href=":github/src/babyfish-collection/:main/org/babyfish/collection/XMap.java">
                                            org.babyfish.collection.XMap.XEntry&lt;K，V&gt;
                                        </a>
                                        接口的isAlive方法。
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend>JDKIssueFixingTest.java</legend>
                                        此测试演示<a href=":github/src/babyfish-collection/:main/:type">org.babyfish.collection.TreeMap&lt;K，V&gt;</a>
                                        修复了"java.util.TreeMap&lt;K，V&gt;"的一个缺陷。
                                    </fieldset>
                                </fieldset>
                                <fieldset class="tree-node package">
                                    <legend>org.babyfishdemo.xcollection.validator</legend>
                                    此测试演示如何使用验证器阻止非法的元素、键、值被添加集合中
                                </fieldset>
                                <fieldset class="tree-node package">
                                    <legend>org.babyfishdemo.xcollection.basic</legend>
                                    <fieldset class="tree-node file">
                                        <legend>EqualityComparatorTest.java</legend>
                                        <p>
                                            我们知道，java.util.TreeSet&lt;E&gt;和java.util.TreeMap&lt;K，V&gt;支持两种比较元素（或键）的方式。
                                            <ul>
                                                <li>让充当元素（或键）的类自身实现java.lang.Comparable接口。</li>
                                                <li>单独用一个类实现java.util.Comparator接口以指定第三方的元素（或键）比较器。</li>
                                            </ul>
                                        </p>
                                        <p>
                                            但是，其余的Set或Map仅允许让充当元素（或键）的类自身覆盖方法“int hashCode()”和“boolean equals(Object)”，
                                            无法单独实现一个类以第三方的方式为集合指定元素（或键）对象的hashCode计算规则，以及其相等性判断规则。
                                        </p>
                                        <p>
                                            为了解决此问题，X集合框架支持
                                            <a href=":github/src/babyfish-collection/:main/:type">org.babyfish.collection.EqualityComparator&lt;T&gt;</a>
                                            接口。开发人员通过实现此接口可以第三方的方式为集合指定元素（或键）对象的hashCode计算规则，以及其相等性判断规则，
                                            而无需让充当元素（或键）的类自身覆盖方法“int hashCode()”和“boolean equals(Object)”。
                                        </p>
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend>ReplacementRuleTest.java</legend>
                                        <p>
                                            在Java集合框架中，Set不允许重复的元素，Map不允许重复的键。
                                        </p>
                                        <p>
                                            假如有一个Set集合，它已经包含一个称为a的元素，现在有一个b对象，虽然a和b不是同一个对象（a != b），但是a和b是相等的（a.equals(b)）。
                                            如果试图将b对象也假如该集合中，很明显，集合的长度不会变化且add方法会返回false。但是，会出现另外一个问题，即可中的元素会从a替换成b吗？ 
                                        </p>
                                        <p>
                                            为了解决此问题，X集合框架的所有Set和Map均支持一个类型为
                                            <a href=":github/src/babyfish-collection/:main/:type">org.babyfish.collection.ReplacementRule</a>.
                                            的初始化参数，它可以控制当即将被添加到集合中的新元素（或键）和集合中某个已经存在的元素（或键）相等的时候，已经存在的元素（或键）是否会被替换为新的元素（或键）。
                                        </p>
                                    </fieldset>
                                </fieldset>
                                <fieldset class="tree-node package">
                                    <legend>org.babyfishdemo.xcollection.bidi</legend>
                                    <p>
                                        很多开源的集合框架支持“Bidi集合”，举一个例子，apache的集合框架commons-collletions支持 
                                        <a href="https://commons.apache.org/proper/commons-collections/apidocs/:type">org.apache.commons.collections4.BidiMap</a>.
                                    </p>
                                    <p>
                                        X集合框架同样也支持此功能，X集合框架中所有List和Map均支持一个类型为
                                        <a href=":github/src/babyfish-collection/:main/:type">org.babyfish.collection.BidiType</a>，
                                        的初始化参数，该参数的某些取值可以保证List元素和Map值的唯一性。
                                    </p>
                                    <fieldset class="tree-node file">
                                        <legend>BidiCollectionTest.java</legend>
                                        <fieldset class="tree-node method">
                                            <legend>testBidiMap</legend>
                                            演示如何让Map的值具备唯一性。
                                        </fieldset>
                                        <fieldset class="tree-node method">
                                            <legend>testBidiList</legend>
                                            演示如何让List的元素具备唯一性。
                                        </fieldset>
                                    </fieldset>
                                </fieldset>
                                <fieldset class="tree-node package">
                                    <legend>org.babyfishdemo.xcollection.unstable</legend>
                                    <p>
                                        此包下的例子演示X集合框架最重要的一个功能：不稳定集合元素。
                                    </p>
                                    <p>
                                        我们知道，Java集合框架支持高性能的哈希结构(如HashSet, HashMap, LinkedHashSet和LinkedHashMap)和红黑树结构（如TreeSet和TreeMap），
                                        但代价是，元素（或键）对象被添加到了哈希结构或红黑树结构以后就绝对不可被修改；否则，哈希结构和红黑树结构就会被破坏，后续效应不可预料。
                                    </p>
                                    <p>
                                        为了解决这个问题，X集合框架针对哈希结构提供了
                                        <a href=":github/src/babyfish-collection/:main/:type">
                                            org.babyfish.collection.FrozenEqualityComparator&lt;T&gt;
                                        </a>
                                        接口，并针对红黑树结构提供了
                                        <a href=":github/src/babyfish-collection/:main/:type">
                                            org.babyfish.collection.FrozenComparator&lt;T&gt;
                                        </a>
                                        接口。这两个第三方比较器接口允许集合支持“不稳定集合元素”。
                                        当某个元素（或键）对象被添加到Set或Map之后，它仍然可以被随意修改，因为包含它的所有Set和Map的内部数据均能在此时被自动调整。
                                    </p>
                                    <fieldset class="tree-node file">
                                        <legend>UnstableCollectionElementsTest.java</legend>
                                        该测试类演示“不稳定集合元素”的基本功能。
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend>ElementCrowdingOutEffectTest.java</legend>
                                        <p>
                                            Set和Map是不支持重复元素（或键）的，但是如果开发人员企图修改某个元素或（键）对象以使之和另外一个元素（或键）相等，会发生什么呢?
                                        </p>
                                        <p>
                                            为了解决这个问题，修改后会冲突的两个元素(或键)中必须有一个被自动从当前集合中删除，这个功能叫“元素排挤效应”。
                                        </p>
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend>BidiCollectionValueCrowdingOutEffectTest.java</legend>
                                        <p>
                                            前面提过，X集合框架只是Bidi集合，BidiMap能保证其值的唯一性，而BidList也能保证其元素的唯一性。
                                        </p>
                                        <p>
                                            所以，BidiMap支持“不稳定Map值”。BidiList支持“不稳定元素”。
                                        </p>
                                    </fieldset>
                                </fieldset>
                            </fieldset>
                        </fieldset>
                        <fieldset class="tree-node project">
                            <legend>babyfishdemo-macollection</legend>
                            BabyFish支持MA(Modification Aware)集合框架，该集合框架由X集合框架扩展而来，用于支持事件通知。 
                            对任何集合对象的任何一个元素，键或值，开发人员的任何修改行为均会在修改前和修改后各自触发一次事件通知。
                            这点和关系型数据库的行级触发器极为类似。
                            <fieldset class="tree-node folder">
                                <legend>src/test/java</legend>
                                <fieldset class="tree-node package">
                                    <legend>org.babyfishdemo.macollection.basic</legend>
                                    演示MA集合框架的基本功能，介绍每种集合接口能触发的事件类型。
                                    <fieldset class="tree-node file">
                                        <legend>ElementListenerTest.java</legend>
                                        该测试类演示集合能触发的最简单的事件类型。
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend>ListElementListenerTest.java</legend>
                                        该测试类演示java.util.List&lt;E&gt;集合能触发的事件类型。
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend>MapElementListenerTest.java</legend>
                                        该测试类演示java.util.Map&lt;K, V&gt;集合能触发的事件类型。
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend>KeySetElementListenerTest.java</legend>
                                        该测试类演示Map的keySet视图能触发的事件类型。
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend>ValuesElementListenerTest.java</legend>
                                        该测试类演示Map的values视图能触发的事件类型。
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend>EntryElementListenerTest.java</legend>
                                        该测试类演示java.util.Map.Entry&lt;K, V&gt;键值对触发的事件类型。
                                    </fieldset>
                                </fieldset>
                                <fieldset class="tree-node package">
                                    <legend>org.babyfishdemo.macollection.modification</legend>
                                    集合接口往往支持很多个方法来修改自身数据。所以，当某个时间被触发是，
                                    事件参数对象通过支持一个名为“modification”的属性来表明该事件是因
                                    开发人员调用了哪个修改方法而被触发，以及相应的调用参数是什么。
                                </fieldset>
                                <fieldset class="tree-node package">
                                    <legend>org.babyfishdemo.macollection.batch</legend>
                                    <p>
                                        Java集合支持很多批量修改数据的方法，比如
                                    </p>
                                    <ul>
                                        <li>java.util.Collection&lt;E&gt;.addAll(java.util.Collection&lt;? extends E> c);</li>
                                        <li>java.util.Collection&lt;E&gt;.clear();</li>
                                        <li>java.util.Collection&lt;E&gt;.removeAll(java.util.Collection&lt;?&gt; c);</li>
                                        <li>java.util.Collection&lt;E&gt;.retainAll(java.util.Collection&lt;?&gt; c);</li>
                                        <li>java.util.List&lt;E&gt;.addAll(int index，java.util.Collection&lt;? extends E> c);</li>
                                        <li>java.util.Map&lt;K，V&gt;.putAll(Map&lt;? extends K，? extends V&gt; m);</li>
                                        <li>java.util.Map&lt;K，V&gt;.clear();</li>
                                    </ul>
                                    <p>
                                        当开发人员调用这些修改方法中的某个时，集合对象的多个元素会受到影响。
                                        其中每一个被影响的集合元素都会触发一对事件：修改前事件和修改后事件。 
                                    </p>
                                    <p>
                                        开发人员可以使用它们定义的事件监听器处理每一对事件，当然，开发人员实现的事件监听器是允许抛出异常的。
                                        为了保证批量修改行为的合理性，MA结合框架保证
                                    </p>
                                    <ul>
                                        <li>如果任何一个修改前事件的监听器实现抛出异常，则没有任何一个元素会被修改。</li>
                                        <li>只要所有的修改前事件的监听器实现运行正常，即使某些修改后事件的监听器实现抛出异常，整个批量修改能影响的每一个元素都会被修改。</li>
                                    </ul>
                                    <p>
                                        也就是说，整个批量修改，要么全部成功，要么全部失败；绝对不可能批量修改完成后，部分元素修改成功而另外的修改失败。
                                    </p>
                                </fieldset>
                                <fieldset class="tree-node package">
                                    <legend>org.babyfishdemo.macollection.implicit</legend>
                                    <fieldset class="tree-node file">
                                        <legend>ImplicitEventTest.java</legend>
                                        <p>
                                            开发任何可以调用集合对象的修改方法修改集合的数据，这叫显式修改。
                                            但是因为X/MA集合框架很强大，某些时候，即便开发人员没有针对集合对象调用任何修改集合数据的方法，集合对象的数据也会被自动修改，这叫隐式修改。
                                        </p>
                                        <p>
                                            此测试类演示，即便集合数据被隐式修改，集合时间仍然会被触发。
                                        </p>
                                        <fieldset class="tree-node method">
                                            <legend>implictEventCausedByBidiMap</legend>
                                            BidiMap需要保证Map的值的唯一性，如果要新加的键值对中的值和当前BidiMap中的某值冲突，那么BidiMap中那个值和相应的键会被自动删除。
                                            这种隐式修改能导致事件触发。
                                        </fieldset>
                                        <fieldset class="tree-node method">
                                            <legend>implictEventCausedByBidiList</legend>
                                            BidiList需要保证List的元素的唯一性，如果要新加的元素的值和当前BidiList中的某个元素冲突，那么BidiList中那个元素会被自动删除。
                                            这种隐式修改能导致事件触发。
                                        </fieldset>
                                        <fieldset class="tree-node method">
                                            <legend>implicitEventCausedByUnstableElements</legend>
                                            和X集合框架一样，MA集合框架同样支持“不稳定Set元素”，
                                            即便一个元素对象已经被添加到了Set中，它也可以被随意修改，所有包含它的Set对象均会被自动调整。
                                            这种隐式修改能导致事件触发。  
                                        </fieldset>
                                        <fieldset class="tree-node method">
                                            <legend>implicitEventCausedByUnstableKeys</legend>
                                            和X集合框架一样，MA集合框架同样支持“不稳定Map键”，
                                            即便一个元素对象已经被作为键添加到了Map中，它也可以被随意修改，所有包含它的Map对象均会被自动调整。
                                            这种隐式修改能导致事件触发。  
                                        </fieldset>
                                        <fieldset class="tree-node method">
                                            <legend>implicitEventCausedByUnstabledBidiValues</legend>
                                            和X集合框架一样，MA集合框架中的BidiMap同样支持“不稳定BidiMap值”，
                                            即便一个元素对象已经被作为值添加到了BidiMap中，它也可以被随意修改，所有包含它的BidiMap对象均会被自动调整。
                                            这种隐式修改能导致事件触发。 
                                        </fieldset>
                                        <fieldset class="tree-node method">
                                            <legend>implicitEventCausedByUnstableBidiElements</legend>
                                            和X集合框架一样，MA集合框架中的BidiList同样支持“不稳定BidiList元素”，
                                            即便一个元素对象已经被添加到了BidiList中，它也可以被随意修改，所有包含它的BidiList对象均会被自动调整。
                                            这种隐式修改能导致事件触发。 
                                        </fieldset>
                                    </fieldset>
                                </fieldset>
                                <fieldset class="tree-node package">
                                    <legend>org.babyfishdemo.macollection.bubble</legend>
                                    <p>
                                        Java集合框架中大量的集合是支持创建视图集合的，
                                        比如“java.util.List.subList(int，int)”，“java.util.Map.keySet()”，
                                        “java.util.NavigableMap.subMap(K，boolean，K，boolean)”，
                                        ”java.util.Collection.iterator()“，等等。当然，视图集合对象自身也可以创建更深层次的视图集合对象。
                                    </p>
                                    <p>
                                        MA集合框架支持“冒泡事件”，当某个视图集合对象被开发人员修改是，首先，该视图对象会触发事件；
                                        然后该事件冒泡到上一层视图集合对象，导致上一层视图集合对象触发事件；以此类推， 
                                        最终，事件会被冒泡到原始集合对象，导致原始集合对象也触发事件。 
                                    </p>
                                    <fieldset class="tree-node file">
                                        <legend>SimpleBubbleEventTest.java</legend>
                                        本测试演示最简单的“事件冒泡”（不考虑基于隐式事件的冒泡事件）
                                        <fieldset class="tree-node method">
                                            <legend>testBubbleEventWithEventTypeDifference</legend>
                                            演示在事件冒泡过程中，事件参数对象的类型会改变的场景。
                                        </fieldset>
                                        <fieldset class="tree-node method">
                                            <legend>testBubbleEventWithEventDataDifference</legend>
                                            演示在事件冒泡过程中，事件参数对象的数据会改变的场景。
                                        </fieldset>
                                    </fieldset>
                                </fieldset>
                            </fieldset>
                        </fieldset>
                        <fieldset class="tree-node project">
                            <legend>babyfishdemo-collections</legend>
                            <fieldset class="tree-node folder">
                                <legend>src/test/java</legend>
                                <fieldset class="tree-node package">
                                    <legend>org.babyfishdemo.collections</legend>
                                    和java.util.Collections类似，BabyFish提供了org.babyfish.collection.MACollections类。
                                    该类针对X集合框架和MA集合框架提供了一些很使用的静态工具方法。
                                    <fieldset class="tree-node file">
                                        <legend>ProxyTypeTest.java</legend>
                                        MACollections支持很多为集合对象提供创建有特殊能力的代理对象的工具方法，
                                        被创建的代理集合的类型取决于参数中原始集合的运行时类型，而非其编译时类型。
                                        举个例子，加入有一个类型为java.util.Collection的变量c，
                                        但事实上，其所指向的集合对象的类型为java.util.TreeMap，
                                        那么通过"MACollections.unmodifiable(c)"创建的代理集合会实现
                                        java.util.NavigableSet接口，而非仅仅实现java.util.Collection接口。
                                        <fieldset class="tree-node method">
                                            <legend>testComparatorType</legend>
                                            演示根据运行时刻实际类型为java.util.Comparator&lt;E&gt;创建代理。
                                            <div class="warning">
                                                对于比较器而言，使用 
                                                “org.babyfish.collection.MACollections.reversedOrder(java.util.Comparator)”
                                                得到逆序比较器代理是很重要的，千万不要使用“java.util.Collections.reversedOrder(java.util.Compartor)”，因为
                                                <ul>
                                                    <li>
                                                        为了支持“不稳定集合元素”，X集合框架从java.util.Comparator&lt;E&gt;扩展出了
                                                        org.babyfish.collection.FrozenComparator&lt;T&gt;接口。
                                                        但是，“java.util.Collections.reversedOrder(java.util.Comparator&lt;E&gt;)”
                                                        返回的代理对象并不会实现FrozenComparator接口。
                                                    </li>
                                                    <li>
                                                        为了让Comparator&lt;T&gt;(或FrozenComparator&lt;E&gt;")接口可以被
                                                        转化为EqualityComparator&lt;T&gt;(或"FrozenEqualityComparator&lt;T&gt;)接口，
                                                        开发人员可以创建同时实现了java.util.Comparator&lt;E&gt;
                                                        和org.babyfish.collection.HashCalculator接口的比较器。
                                                        但是“java.util.Collections.reversedOrder(java.util.Comparator&lt;E&gt;)”
                                                        返回的代理并不会实现HashCalculator接口。
                                                    </li>
                                                </ul>
                                            </div>
                                        </fieldset>
                                        <fieldset class="tree-node method">
                                            <legend>testCollectionType</legend>
                                            演示根据运行时刻实际类型为java.util.Collection&lt;E&gt;创建代理。
                                        </fieldset>
                                        <fieldset class="tree-node method">
                                            <legend>testMapType</legend>
                                            演示根据运行时刻实际类型为java.util.Map&lt;K, V&gt;创建代理。
                                            by its runtime-type.
                                        </fieldset>
                                        <fieldset class="tree-node method">
                                            <legend>testIteratorType</legend>
                                            演示根据运行时刻实际类型为java.util.Iterator&lt;E&gt;创建代理。
                                        </fieldset>
                                        <fieldset class="tree-node method">
                                            <legend>testEntryType</legend>
                                            演示根据运行时刻实际类型为java.util.Map.Entry&lt;K, V&gt;创建代理。
                                        </fieldset>
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend>ReadWriteLockSupportingTest.java</legend>
                                        <p>
                                            和“java.util.Collections.synchronized...()”类似，MACollections 
                                            提供了一些静态方法，用于为线程不安全的集合创建线程安全的代理集合。
                                        </p>
                                        <p>
                                            “MACollections.locked(...)”并不会使用Java的synchronized关键字，
                                            它返回的线程安全代理集合是基于读写锁java.util.concurrent.locks.ReadWriteLock的，
                                            所以，线程安全代理集合对象上那些不会对集合数据有影响的只读方法是只会使用读锁的。
                                        </p>
                                        <div class="warning">
                                            如果集合支持读写锁是可能的，原始集合对象必须实现org.babyfish.lang.LockDescriptor接口并使其
                                            “isReadWriteLockSupported()”方法返回true。
                                            否则，表示原始集合不支持读写锁，根据“MACollections.locked(...)”创建出的代理集合的所有方法均使用写锁。
                                        </div>
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend>OptimizationTest.java</legend>
                                        演示MACollections的优化行为
                                        <fieldset class="tree-node method">
                                            <legend>testIgnoreDuplicateUnmodifiableProxies</legend>
                                            演示对“MACollections.unmodifable(...)”冗余调用的自动去除冗余行为。
                                        </fieldset>
                                        <fieldset class="tree-node method">
                                            <legend>testIgnoreDuplicateLockedProxies</legend>
                                            演示对“MACollections.lock(...)”冗余调用的自动去除冗余行为。
                                        </fieldset>
                                        <fieldset class="tree-node method">
                                            <legend>testIgnoreDuplicateMixedProxies</legend>
                                            演示对“MACollections.unmodifable(...)”以及MACollections.lock(...)”
                                            的冗余调用的自动去除冗余行为。
                                        </fieldset>
                                        <fieldset class="tree-node method">
                                            <legend>testGatewayPriority</legend>
                                            演示只读代理集合拥有最高优先级，无论创建代理链的先后顺序如何，
                                            只读代理总是最为最外层代理包裹线程安全代理。
                                            所以绝对不可能出现当前线程先获取到锁，然后发现集合是只读的而需要放弃锁直接抛出异常的情况。
                                        </fieldset>
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend>LockPropagationTest.java</legend>
                                        <p>
                                            有时线程安全集合锁使用的锁的作用域会显得太小，
                                            举一个例子，"java.util.Collections.synchronized...(...)"能返回线程安全的集合代理，
                                            但是开发人员使用循环操作其迭代器是线程不安全的行为，JDK要求开发人员在此时需要手动为
                                            整个迭代器循环上锁，然而，这项工作的总是容易被人遗忘的。
                                        </p>
                                        <p>
                                            为了解决这个问题，BabyFish支持“锁传播”功能，
                                            对于线程安全的集合而言，开发人员可以调用其API拓展其索的作用域。
                                        </p>
                                        <div class="warning">
                                            “java.util.Collections.sysnchronized...(...)”虽然返回线程安全的代理集合，
                                            但对迭代器的循环却仍然需要开发人员记得上锁，与之不同的是
                                            “org.babyfish.collection.MACollections.locked(...)"
                                            返回的代理集合通过异常告知开发人员，该代理是无法获取迭代器的，并提示开发人员先应该使用
                                            “MACollections.locking(...)”方法延展锁的作用域。
                                        </div>
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend>PrimitiveListTest.java</legend>
                                        演示如何将基本类型的数组对象包装成list，此功能类似于“java.util.Arrays.asLsit(T...)”，
                                        但是其参数接受基本类型数组。
                                        <p>
                                            在Java语言中，泛型参数不能是基本类型的，
                                            所以”java.util.List&lt;Ineger&gt;“是合法的，但是“java.util.List&lt;int&gt;”
                                            是非法的。在传统的解决方案中，我们不得不先将“int[]”转化为“Integer[]”，
                                            再调用“java.util.Arrays.asList”得到List集合。所有的"int"都被装箱成了
                                            Integer对象，如果其中很大一部分对象被移动到了GC的老代（或老块）中，这对GC而言可不是一件好事。 
                                        </p>
                                        <p>
                                            BabyFish支持”MACollections.wrapXXX(...)“方法，该方法能将基本类型数据对象直接包装成List集合，
                                            该集合并不是将所有元素装箱成Integer对象，而是直接保持基本类型数组。 
                                            最终，这些"int"元素在被用户读取或迭代时才会临时装箱成“Integer”对象。
                                            这种选择并不差，因为这些临时装箱的“Integer”对象往往存在在GC的年轻代（或年轻块）中并会被用户快速丢弃，
                                            这对GC而言，是一件好事。
                                        </p>
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend>EntrySetProtectionTest.java</legend>
                                        演示”MACollections.undifiable(map.entrySet());“返回的Set中的每一个
                                        java.util.Map.Entry&lt;K，V&gt;对象的setValue方法都会被禁止。
                                        （经典的开发中，你只能换一种方法来达到同样目的，使用“Collections.unmodifiableMap(map).entrySet()”）
                                    </fieldset>
                                </fieldset>
                            </fieldset>
                        </fieldset>
                        <fieldset class="tree-node project">
                            <legend><a id="babyfishdemo-om4java">babyfishdemo-om4java</a></legend>
                            <p>
                                ObjectModel是BabyFish的核心功能，它分为两个部分，ObjectModel4Java和ObjectModel4JPA。
                                本工程仅仅演示ObjectModel4Java。
                            </p>
                            <p>
                                ObjectModel4Java既支持对象之间单向关联，也支持对象之间的双向关联。
                                然而，ObjectModel4Java的价值就是为双向关联提供强大的功能以创建智能的对象图。
                                所以，没有必要演示单向关联，本工程仅仅演示ObjectModel4Java的双向关联。
                            </p>
                            <p>
                                对ObjectModel中的对象之间双向关联而言，
                                当其中任何一端的数据被开发人员以任何方式修改时，都会导致事件通知的触发，双向关联的另外外一端收到事件通知后，其据都会被自动修改。
                            </p>
                            <div class="info">
                                本工程有很多类使用了注解 
                                <a href=":github/src/babyfish-model/:main/:type">@org.babyfish.model.Model</a>，
                                该注解需要在<a href="!project/pom.xml">pom.xml</a>中配置相应的Maven插件以启用ObjectModel4Java所需的编译时字节码增强。
                                <div class="code">
                                    <pre>&lt;plugin&gt;
  &lt;groupId>org.babyfish&lt;/groupId&gt;
  &lt;artifactId&gt;babyfish-instrument-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;${babyfish.version}&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;goals&gt;
        &lt;goal&gt;instrument&lt;/goal&gt;
      &lt;/goals&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.babyfish&lt;/groupId&gt;
      &lt;artifactId&gt;babyfish-model-tool&lt;/artifactId&gt;
      &lt;version&gt;${babyfish.version}&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/plugin&gt;</pre>
                                </div>
                            </div>
                            <fieldset class="tree-node folder">
                                <legend>src/test/java</legend>
                                <fieldset class="tree-node package">
                                    <legend><a id="om4java.r2r">org.babyfishdemo.om4java.r2r</a></legend>
                                    在项目产品代码目录<a href="!project/:main">src/main/java</a>中，
                                    <a href="!project/:main/:type">org.babyfishdemo.om4java.r2r.Person</a>
                                    类具备一个spouse字段，该字段被
                                    <a href=":github/src/babyfish-model/:main/:type">@org.babyfish.model.Association</a>
                                    注解修饰，此注解的opposite参数是spouse，表示改字段自己和自己形成了双向关联。
                                    这声明了一个双向的一对一关联。
                                    <fieldset class="tree-node file">
                                        <legend>ObjectModelOfReferenceAndReferenceTest.java</legend>
                                        演示双向一对一关联的智能性。
                                    </fieldset>
                                </fieldset>
                                <fieldset class="tree-node package">
                                    <legend><a id="om4java.s2r">org.babyfishdemo.om4java.s2r</a></legend>
                                    在项目产品代码目录<a href="!project/:main">src/main/java</a>中，
                                    <ul>
                                        <li>
                                            <a href="!project/:main/:type">org.babyfishdemo.om4java.s2r.Department</a>
                                            类使用被
                                            <a href=":github/src/babyfish-model/:main/:type">@org.babyfish.model.Association</a>
                                            注解修饰的employees字段来定义当前类和
                                            <a href="!project/:main/:type">org.babyfishdemo.om4java.s2r.Employee</a>
                                            类之间的集合关联。
                                        </li>
                                        <li>
                                            <a href="!project/:main/:type">org.babyfishdemo.om4java.s2r.Employee</a>
                                            类使用被
                                            <a href=":github/src/babyfish-model/:main/:type">@org.babyfish.model.Association</a>
                                            注解修饰的department字段来定义当前类和
                                            <a href="!project/:main/:type">org.babyfishdemo.om4java.s2r.Department</a>
                                            类之间的引用关联。
                                        </li>
                                        <li>
                                            “<a href="!project/:main/:package/:type">Department</a>.employees”
                                            和
                                            ”<a href="!project/:main/:package/:type">Employee</a>.department“
                                            字段彼此使用各自的
                                            <a href=":github/src/babyfish-model/:main/:type">@org.babyfish.model.Association</a>
                                            注解的opposite参数来引用对方，互为镜像。
                                        </li>
                                    </ul>
                                    这样就完成了一个双向一对多关联的声明。
                                    <fieldset class="tree-node file">
                                        <legend>ObjectModelOfSetAndReferenceTest.java</legend>
                                        演示双向一对多关联的智能性。
                                    </fieldset>
                                </fieldset>
                                <fieldset class="tree-node package">
                                    <legend><a id="om4java.l2ir">org.babyfishdemo.om4java.l2ir</a></legend>
                                    在项目产品代码目录<a href="!project/:main">src/main/java</a>中，
                                    <ul>
                                        <li>
                                            <a href="!project/:main/:type">org.babyfishdemo.om4java.l2ir.Department</a>
                                            类使用被
                                            <a href=":github/src/babyfish-model/:main/:type">@org.babyfish.model.Association</a>
                                            注解修饰的employees字段来定义当前类和
                                            <a href="!project/:main/:type">org.babyfishdemo.om4java.l2ir.Employee</a>
                                            类之间的集合关联。
                                        </li>
                                        <li>
                                            <a href="!project/:main/:type">org.babyfishdemo.om4java.l2ir.Employee</a>
                                            类使用被
                                            <a href=":github/src/babyfish-model/:main/:type">@org.babyfish.model.Association</a>
                                            注解修饰的department字段来定义当前类和
                                            <a href="!project/:main/:type">org.babyfishdemo.om4java.l2ir.Department</a>
                                            类之间的引用关联。
                                        </li>
                                        <li>
                                            ”<a href="!project/:main/:package/:type">Department</a>.employees“
                                            和
                                            ”<a href="!project/:main/:package/:type">Employee</a>.department“
                                            彼此使用各自的
                                            <a href=":github/src/babyfish-model/:main/:type">@org.babyfish.model.Association</a>
                                            注解的opposite参数来引用对方，互为镜像。
                                        </li>
                                        <li>
                                            ”<a href="!project/:main/:package/:type">Employee</a>.index“
                                            字段使用
                                            <a href=":github/src/babyfish-model/:main/:type">@org.babyfish.model.IndexOf</a>
                                            注解来依附于同一个类中的
                                            “<a href="!project/:main/:package/:type">Employee</a>.department”
                                            字段。
                                            这意味着“<a href="!project/:main/:package/:type">Employee</a>.index”
                                            字段代表当前对象在
                                            "<a href="!project/:main/:package/:type">Employee</a>.department"
                                            字段所指向的父对象的List集合中的索引。
                                        </li>
                                        <li>
                                            “<a href="!project/:main/:type">org.babyfishdemo.om4java.l2ir.Employee</a>.index”
                                            字段的注解
                                            <a href=":github/src/babyfish-model/:main/:type">@org.babyfish.model.IndexOf</a>
                                            的absolute参数因未配置而采用了默认值false，这表示
                                            “<a href="!project/:main/:package/:type">Employee</a>.index“
                                            字段脱离
                                            “<a href="!project/:main/:package/:type">Employee</a>.department”.
                                            字段就没有意义，当某个对象的
                                            ”<a href="!project/:main/:package/:type">Employee</a>.department“
                                            字段为null时，其
                                            “<a href="!project/:main/:package/:type">Employee</a>.index”
                                            总会在被开发人员读取时表现成-1，直到
                                            该对象的“<a href="!project/:main/:package/:type">Employee</a>.department”
                                            字段变成非空为止。
                                        </li>
                                    </ul>
                                    这样就完成了一个子对象能维护自己在所属父对象的List集合中的索引的双向一对多关联的声明。
                                    <fieldset class="tree-node file">
                                        <legend>ObjectModelOfListAndIndexedReferenceTest.java</legend>
                                        演示子对象能维护自己在所属父对象的List集合中的索引的双向一对多关系的智能性。
                                    </fieldset>
                                </fieldset>
                                <fieldset class="tree-node package">
                                    <legend><a id="om4java.l2r">org.babyfishdemo.om4java.l2r</a></legend>
                                    在项目产品代码目录<a href="!project/:main">src/main/java</a>中，
                                    <ul>
                                        <li>
                                            <a href="!project/:main/:type">org.babyfishdemo.om4java.l2r.Department</a>
                                            类使用被
                                            <a href=":github/src/babyfish-model/:main/:type">@org.babyfish.model.Association</a>
                                            注解修饰的employees字段来定义当前类和
                                            <a href="!project/:main/:type">org.babyfishdemo.om4java.l2r.Employee</a>
                                            类之间的集合关联。
                                        </li>
                                        <li>
                                            <a href="!project/:main/:type">org.babyfishdemo.om4java.l2r.Employee</a>
                                            类使用被
                                            <a href=":github/src/babyfish-model/:main/:type">@org.babyfish.model.Association</a>
                                            注解修饰的department字段来定义当前类和
                                            <a href="!project/:main/:type">org.babyfishdemo.om4java.l2r.Department</a>
                                            类之间的引用关联。
                                        </li>
                                        <li>
                                            “<a href="!project/:main/:package/:type">Department</a>.employees”
                                            和
                                            “<a href="!project/:main/:package/:type">Employee</a>.department”
                                            字段彼此使用各自的
                                            <a href=":github/src/babyfish-model/:main/:type">@org.babyfish.model.Association</a>
                                            注解的opposite参数来引用对方，互为镜像。
                                        </li>
                                    </ul>
                                    这样就完成了一个一对多双向关联的声明。
                                    <fieldset class="tree-node file">
                                        <legend>ObjectModelOfListAndReferenceTest.java</legend>
                                        <div class="info">
                                            <p>
                                                这种关联的功能是之前已经在 
                                                <a href="!project/:test/:type">
                                                    org.babyfishdemo.om4java.l2ir.ObjectModelOfListAndIndexedReferenceTest
                                                </a>
                                                章节中被演示过的那种双向关联的功能的子集。
                                            </p> 
                                            <p>
                                                所以没有必要重复演示一遍，相应的单元测试类是空的，该空类仅仅是为了保持代码风格一致性而占位而已。
                                            </p>
                                        </div>
                                    </fieldset>
                                </fieldset>
                                <fieldset class="tree-node package">
                                    <legend><a id="om4java.m2kr">org.babyfishdemo.om4java.m2kr</a></legend>
                                    在项目产品代码目录<a href="!project/:main">src/main/java</a>中，
                                    <ul>
                                        <li>
                                            <a href="!project/:main/:type">org.babyfishdemo.om4java.m2kr.Element</a>
                                            类使用被
                                            <a href=":github/src/babyfish-model/:main/:type">@org.babyfish.model.Association</a>
                                            注解修饰的attributes字段来声明当前类和
                                            <a href="!project/:main/:type">org.babyfishdemo.om4java.m2kr.Attribute</a>
                                            类之间的集合关联。
                                        </li>
                                        <li>
                                            <a href="!project/:main/:type">org.babyfishdemo.om4java.m2kr.Attribute</a>
                                            类使用被
                                            <a href=":github/src/babyfish-model/:main/:type">@org.babyfish.model.Association</a>
                                            注解修饰的element字段来声明当前类和
                                            <a href="!project/:main/:type">org.babyfishdemo.om4java.m2kr.Element</a>
                                            类之间的引用关联。
                                        </li>
                                        <li>
                                            “<a href="!project/:main/:package/:type">Element</a>.attributes”
                                            和
                                            “<a href="!project/:main/:package/:type">Attribute</a>.element”
                                            彼此使用各自的
                                            <a href=":github/src/babyfish-model/:main/:type">@org.babyfish.model.Association</a>
                                            注解的opposite参数来引用对方，互为镜像。
                                        </li>
                                        <li>
                                            “<a href="!project/:main/:package/:type">Attribute</a>.name”
                                            字段使用
                                            <a href=":github/src/babyfish-model/:main/:type">@org.babyfish.model.KeyOf</a>
                                            注解来依附同一个类的
                                            “<a href="!project/:main/:package/:type">Attribute</a>.element”
                                            字段，这意味着
                                            “<a href="!project/:main/:package/:type">Attribute</a>.name”
                                            字段代表当前对象在
                                            “<a href="!project/:main/:package/:type">Attribute</a>.element”
                                            字段所指向的父对象的Map集合中的键。
                                        </li>
                                        <li>
                                            “<a href="!project/:main/:package/:type">Attribute</a>.name”
                                            字段的注解
                                            <a href=":github/src/babyfish-model/:main/:type">@org.babyfish.model.KeyOf</a>
                                            的absolute参数因未配置而采用了默认值false，这表示
                                            “<a href="!project/:main/:package/:type">Attribute</a>.name”
                                            字段脱离 
                                            “<a href="!project/:main/:package/:type">Attribute</a>.element”
                                            字段就没有意义，当某个对象的
                                            “<a href="!project/:main/:package/:type">Attribute</a>.element”
                                            字段为null时，其
                                            “<a href="!project/:main/:package/:type">Attribute</a>.name”
                                            总会在被开发人员读取时表现成null，直到 
                                            “<a href="!project/:main/:package/:type">Attribute</a>.element”
                                             字段变成非空为止。
                                        </li>
                                    </ul>
                                    这样就完成了一个子对象能维护自己在所属父对象的子对象Map集合中的键的双向一对多关联的声明。
                                    <fieldset class="tree-node file">
                                        <legend>ObjectModelOfMapAndKeyedReferenceTest.java</legend>
                                        演示子对象能维护自己在所属父对象的Map集合中的键的双向一对多关系的智能性。
                                    </fieldset>
                                </fieldset>
                                <fieldset class="tree-node package">
                                    <legend><a id="om4java.m2r">org.babyfishdemo.om4java.m2r</a></legend>
                                    在项目产品代码目录<a href="!project/:main">src/main/java</a>中，
                                    <ul>
                                        <li>
                                            <a href="!project/:main/:type">org.babyfishdemo.om4java.m2r.Airplane</a>
                                            类使用被
                                            <a href=":github/src/babyfish-model/:main/:type">@org.babyfish.model.Association</a>
                                            注解修饰的engines字段来声明当前类和
                                            <a href="!project/:main/:type">org.babyfishdemo.om4java.m2r.Engine</a>
                                            类之间的集合关联。
                                        </li>
                                        <li>
                                            <a href="!project/:main/:type">org.babyfishdemo.om4java.m2r.Engine</a>
                                            类使用被
                                            <a href=":github/src/babyfish-model/:main/:type">@org.babyfish.model.Association</a>
                                            注解修饰的airplane字段来声明当前类和
                                            <a href="!project/:main/:type">org.babyfishdemo.om4java.m2r.Airplane</a>
                                            类之间的引用关联。
                                        </li>
                                        <li>
                                            “<a href="!project/:main/:package/:type">Airplane</a>.engines”
                                            和
                                            “<a href="!project/:main/:package/:type">Engine</a>.airplane”
                                            字段彼此使用各自的
                                            <a href=":github/src/babyfish-model/:main/:type">@org.babyfish.model.Association</a>
                                            注解的opposite参数来引用对方，互为镜像。
                                        </li>
                                    </ul>
                                    That means a bidiretional one-to-many association is declared.
                                    <fieldset class="tree-node file">
                                        <legend>ObjectModelOfMapAndReferenceTest.java</legend>
                                        <div class="info">
                                            <p>
                                                这种双向关联的功能是之前已经在 
                                                <a href="!project/:test/:type">
                                                    org.babyfishdemo.om4java.m2kr.ObjectModelOfMapAndKeyedReferenceTest
                                                </a>
                                                章节中被演示过的那种双向关联的功能的子集。
                                            </p>
                                            <p>
                                                所以没有必要再次演示一遍，相应的单元测试仅仅演示二者之间的细微区别。即不能通过将多对一端字段设置为非空来新建父子对象之间的关联，此目的只能通过修改一对多端的Map集合达到。
                                            </p>
                                        </div>
                                    </fieldset>
                                </fieldset>
                                <fieldset class="tree-node package">
                                    <legend><a id="om4java.s2s">org.babyfishdemo.om4java.s2s</a></legend>
                                    在项目产品代码目录<a href="!project/:main">src/main/java</a>中，
                                    <ul>
                                        <li>
                                            <a href="!project/:main/:type">org.babyfishdemo.om4java.s2s.Company</a>
                                            类使用被
                                            <a href=":github/src/babyfish-model/:main/:type">@org.babyfish.model.Association</a>
                                            注解修饰的investors字段来声明当前类和
                                            <a href="!project/:main/:type">org.babyfishdemo.om4java.s2s.Investor</a>
                                            类之间的集合关联。
                                        </li>
                                        <li>
                                            <a href="!project/:main/:type">org.babyfishdemo.om4java.s2s.Investor</a>
                                            类使用被
                                            <a href=":github/src/babyfish-model/:main/:type">@org.babyfish.model.Association</a>
                                            注解修饰的companies字段了来声明当前类和
                                            <a href="!project/:main/:type">org.babyfishdemo.om4java.s2s.Company</a>
                                            类之间的引用关联。
                                        </li>
                                        <li>
                                            “<a href="!project/:main/:package/:type">Company</a>.investors”
                                            和
                                            “<a href="!project/:main/:package/:type">Investor</a>.companies”
                                            彼此使用各自的
                                            <a href=":github/src/babyfish-model/:main/:type">@org.babyfish.model.Association</a>
                                            注解的opposite参数来引用对方，互为镜像。
                                        </li>
                                    </ul>
                                    这样就完成了一个双向多对多关系的声明。
                                    <fieldset class="tree-node file">
                                        <legend>ObjectModelOfSetAndSetTest.java</legend>
                                        <p>
                                            演示双向多对多关联的智能性。
                                        </p>
                                    </fieldset>
                                </fieldset>
                                <fieldset class="tree-node package">
                                    <legend><a id="om4java.l2s">org.babyfishdemo.om4java.l2s</a></legend>
                                    <p>
                                        演示两端由java.util.List&lt;E&gt;和java.util.Set&ltE&gt;构成的双向关联。
                                    </p>
                                </fieldset>
                                <fieldset class="tree-node package">
                                    <legend><a id="om4java.m2s">org.babyfishdemo.om4java.m2s</a></legend>
                                    <p>
                                        演示两端由java.util.Map&lt;K, V&gt;和java.util.Set&ltE&gt;构成的双向关联。
                                    </p>
                                    <div class="info">
                                        不能通过为Set端添加新元素来新建不同对象之间的关联，这个目的只能通过为Map端添加新键值对来实现。
                                    </div>
                                </fieldset>
                                <fieldset class="tree-node package">
                                    <legend><a id="om4java.fec">org.babyfishdemo.om4java.fec</a></legend>
                                    <p>
                                        和<a href="!project/:test/:package">org.babyfishdemo.om4java.s2r</a>包不同，
                                        此包演示如何在集合关联字段上应用X集合框架的“不稳定集合元素功能”。
                                    </p>
                                    <p>
                                        在项目产品代码目录<a href="!project/:main">src/main/java</a>中，
                                        <a href="!project/:main/:type">org.babyfishdemo.om4java.fec.Department</a>，
                                        类的字段employees被
                                        <a href=":github/src/babyfish-model/:main/:type">@org.babyfish.model.ComparatorRule</a>
                                        注解修饰，该注解使用
                                        <a href="!project/:main/:type">org.babyfishdemo.om4java.fec.Employee</a>
                                        类的两个标量字段作为其参数：firstName和lastName。
                                    </p>
                                    <p>
                                        “<a href="!project/:main/:type">org.babyfishdemo.om4java.fec.Department</a>.employees”
                                        字段被定义为java.util.Set，而非java.util.SortedSet或其派生接口，所以它的实现类似于LinkedHashSet。
                                        其<a href=":github/src/babyfish-model/:main/:type">@org.babyfish.model.ComparatorRule</a>
                                        注解使用firstName和lastName作为其参数，表示该Set使用
                                        “<a href="!project/:main/:type">org.babyfishdemo.om4java.fec.Employee</a>.firstName”
                                        and
                                        “<a href="!project/:main/:type">org.babyfishdemo.om4java.fec.Employee</a>.lastName”
                                        字段了来计算employee对象的哈希code以及判断两个employee对象是否相等。
                                    </p>
                                    <p>
                                        在编译时字节码增强完成之后，一个实现了
                                        <a href=":github/src/babyfish-collection/:main/:type">org.babyfish.collection.FrozenEqualityComparator</a>
                                        接口的类被生成，它唯一的实例被
                                        “<a href="!project/:main/:type">org.babyfishdemo.om4java.fec.Department</a>.employees”
                                        所使用，这表示该集合支持X集合框架的“不稳定集合元素的功能”，
                                        即使某个<a href="!project/:main/:type">org.babyfishdemo.om4java.fec.Employee</a>
                                        已经添加到该集合中，它的firstName和lastName字段仍然可以被随意修改，此集合会因其变动而被自动调整。 
                                    </p>
                                    <fieldset class="tree-node file">
                                        <legend>FrozenEqualityComparatorTest.java</legend>
                                        基于
                                        <a href=":github/src/babyfish-collection/:main/:type">org.babyfish.collection.FrozenEqualityComparator</a>,
                                        演示ObjectModel4Java中的“稳定集合元素”(当然，也包含“元素排挤效应”) 。
                                    </fieldset>
                                </fieldset>
                                <fieldset class="tree-node package">
                                    <legend><a id="om4java.fc">org.babyfishdemo.om4java.fc</a></legend>
                                    <p>
                                        和<a href="!project/:test/:package">org.babyfishdemo.om4java.s2r</a>包不同，
                                        此包演示如何在集合关联字段上应用X集合框架的“不稳定集合元素功能”。
                                    </p>
                                    <p>
                                        在项目产品代码目录<a href="!project/:main">src/main/java</a>中，
                                        <a href="!project/:main/:type">org.babyfishdemo.om4java.fc.Department</a>，
                                        类的字段employees被注解
                                        <a href=":github/src/babyfish-model/:main/:type">@org.babyfish.model.ComparatorRule</a>
                                        注解修饰，该注解使用
                                        <a href="!project/:main/:type">org.babyfishdemo.om4java.fc.Employee</a>
                                        类的两个标量字段作为其参数：firstName和lastName。
                                    </p>
                                    <p>
                                        “<a href="!project/:main/:type">org.babyfishdemo.om4java.fc.Department</a>.employees”
                                        字段被声明为java.util.NavigableSet，该接口派生于java.util.SortedSet接口。
                                        其<a href=":github/src/babyfish-model/:main/:type">@org.babyfish.model.ComparatorRule</a>
                                        firstName和lastName作为其参数，表示该Set使用
                                        “<a href="!project/:main/:type">org.babyfishdemo.om4java.fc.Employee</a>.firstName”
                                        and
                                        “<a href="!project/:main/:type">org.babyfishdemo.om4java.fc.Employee</a>.lastName”
                                        来比较两个employee对象之间的大小。
                                    </p>
                                    <p>
                                        当编译时字节码增强完成后，一个实现了
                                        <a href=":github/src/babyfish-collection/:main/:type">org.babyfish.collection.FrozenComparator</a>
                                        接口的类将被生成，它唯一的实例将被
                                        “<a href="!project/:main/:type">org.babyfishdemo.om4java.fc.Department</a>.employees”
                                        所使用，这表示该集合支持X集合框架的“不稳定集合元素的功能”，
                                        即使某个<a href="!project/:main/:type">org.babyfishdemo.om4java.fc.Employee</a>
                                        已经添加到该集合中，它的firstName和lastName字段仍然可以被随意修改，此集合会因其变动而被自动调整。  
                                    </p>
                                    <fieldset class="tree-node file">
                                        <legend>FrozenComparatorTest.java</legend>
                                        基于
                                        <a href=":github/src/babyfish-collection/:main/:type">org.babyfish.collection.FrozenComparator</a>,
                                        演示ObjectModel4Java中的“不稳定集合元素”(当然，也包含“元素排挤效应”) 。
                                    </fieldset>
                                </fieldset>
                                <fieldset class="tree-node package">
                                    <legend>org.babyfishdemo.om4java.embeddable</legend>
                                    <p>
                                        在项目产品代码目录<a href="!project/:main">src/main/java</a>中，
                                        <a href="!project/:main/:type">org.babyfishdemo.om4java.embeddable.Contact</a>，
                                        <a href="!project/:main/:type">org.babyfishdemo.om4java.embeddable.ElectronicalInfo</a>
                                        和
                                        <a href="!project/:main/:type">org.babyfishdemo.om4java.embeddable.Name</a>
                                        类被参数为
                                        “<a href=":github/src/babyfish-model/:main/:type">@org.babyfish.model.ModelType</a>.EMBEDDABLE”
                                        的注解<a href=":github/src/babyfish-model/:main/:type">@org.babyfish.model.Model</a>修饰。
                                        这叫内嵌模型类。
                                    </p>
                                    <p>
                                        内嵌模型类不能被其它关联字段使用，它只能被其它标量字段使用（或者作为Map关联属性的键类型）。
                                        对于标量属性而言，其类型可以是内嵌类型，当然，内嵌类型的标量属性也可以是另外一个内嵌类型。  
                                        这表示开发人员可以利用内嵌类型形成内嵌链。
                                    </p>
                                    <p>
                                        当最深的内嵌模型类的对象被开发人员修改时，标量属性修改事件将会在这个最深的内嵌模型对象上触发，然后事件将会冒泡到
                                        上一级内嵌模型对象，进而让上一层内嵌对象也能知道它被修改了，以此类推，最终，事件会冒泡到模式为
                                        “<a href=":github/src/babyfish-model/:main/:type">@org.babyfish.model.ModelType</a>.REFERENCE”
                                        的顶成的普通模型对象，该顶层对象会知道它的某个标量属性已经被修改，这个机制和MA集合框架中的事件冒泡机制非常类似。
                                    </p>
                                    <fieldset class="tree-node file">
                                        <legend>EmbeddableTest.java</legend>
                                        演示ObjectModel的”冒泡标量事件“。
                                    </fieldset>
                                </fieldset>
                                <fieldset class="tree-node package">
                                    <legend><a id="om4java.contravariance">org.babyfishdemo.om4java.contravariance</a></legend>
                                    <p>
                                        C#语言从4.0开始支持一个强大的功能：逆变。此功能被ObjectModel学习借鉴。
                                    </p>
                                    <p>
                                        假设有两个类，A和B，其中A为超类，B为派生类。
                                    </p>
                                    <ul>
                                        <li>将java.util.Collection&lt;A&gt;转换为java.util.Collection&lt;B&gt;叫做逆变。</li>
                                        <li>将java.util.Collection&lt;B&gt;转换为java.util.Collection&lt;A&gt;叫做协变。</li>
                                    </ul>
                                    <p>
                                        在项目产品代码目录<a href="!project/:main">src/main/java</a>中，
                                    </p>
                                    <ul>
                                        <li>
                                            “<a href="!project/:main/:type">org.babyfishdemo.om4java.contravariance.TabControl</a>.tagPages”
                                            字段被
                                            <a href=":github/src/babyfish-model/:main/:type">@org.babyfish.model.Contravariance</a>
                                            注解修饰，这表示它和
                                            “<a href="!project/:main/:type">org.babyfishdemo.om4java.contravariance.Container</a>.components”
                                            共享相同的一份数据，只不过它在编译时和运行时两个方面，添加了更为严格类型约束而已。
                                        </li>
                                        <li>
                                            <a href="!project/:main/:type">org.babyfishdemo.om4java.contravariance.TabPage</a>.parent
                                            字段被
                                            <a href=":github/src/babyfish-model/:main/:type">@org.babyfish.model.Contravariance</a>，
                                            注解修饰，这表示它和
                                            "<a href="!project/:main/:type">org.babyfishdemo.om4java.contravariance.Component</a>.parent"
                                            共享相同的一份数据，只不过它在编译时和运行时两个方面，添加了更为严格类型约束而已。
                                        </li>
                                    </ul>
                                    <fieldset class="tree-node file">
                                        <legend>ContravarianceListTest.java</legend>
                                        演示集合属性的逆变。
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend>ContravarianceReferenceTest.java</legend>
                                        演示引用属性的逆变。
                                    </fieldset>
                                </fieldset>
                            </fieldset>
                        </fieldset>
                        <fieldset class="tree-node project">
                            <legend>
                                <span class="comprehensive">
                                    <a id="babyfishdemo-om4java-dom">babyfishdemo-om4java-dom</a>
                                </span>
                            </legend>
                            <p>
                                <span class="comprehensive">这是ObjectModel4Java的综合性示例</span>，
                                它演示了如何利用ObjectModel4Java非常快速地实现一套XML DOM(Document Object Model)的API。 
                                （其功能和dom4j类似，但实现超级简单，仅需要声明数据结构，无需实现逻辑）
                            </p>
                            <fieldset class="tree-node package">
                                <legend>src/main/java</legend>
                                <div class="warning">
                                    <p>
                                        在W3C的XML规范中，org.w3c.dom.Node应该具备12个非抽象派生类： 
                                        org.w3c.dom.Element，org.w3c.dom.Attr，Text，org.w3c.dom.CDATASection，
                                        org.w3c.dom.EntityReference，org.w3c.dom.Entity，org.w3c.dom.ProcessingInstruction，
                                        org.w3c.dom.Comment，org.w3c.dom.Document，org.w3c.dom.DocumentType，
                                        org.w3c.dom.DocumentFragment和org.w3c.dom.Notation。
                                    </p>
                                    <p>
                                        和W3C规范不同，这里做了一定的简化，以让ObjectModel4Java的综合例子更容易学习，
                                        <a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a> 
                                        仅仅支持如下4个非抽象派生类: 
                                    </p>
                                    <ul>
                                        <li><a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Element</a></li>
                                        <li><a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Attribute</a></li>
                                        <li><a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Text</a></li>
                                        <li><a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Comment</a></li>
                                    </ul>
                                </div>
                            </fieldset>
                            <fieldset class="tree-node folder">
                                <legend>src/test/java</legend>
                                <fieldset class="tree-node package">
                                    <legend>org.babyfishdemo.om4java.dom</legend>
                                    <fieldset class="tree-node file">
                                        <legend>CreationTest.java</legend>
                                        <p>演示如何创建XML节点树。</p>
                                        <fieldset class="tree-node method">
                                            <legend>testCreateTreeByAddChildToParent</legend>
                                            <p>演示以将子对象加入父对象集合属性的方式创建XML节点树。</p>
                                            <ul>
                                                <li>
                                                    当将Node子对象加入父对象的 
                                                    “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Element</a>.childNodes”
                                                    集合字段时，子对象的
                                                    ”<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.index“
                                                    和
                                                    “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.parentNode”
                                                    字段均会被自动修改。
                                                </li>
                                                <li>
                                                    当将Attribute子对象加入父对象的 
                                                    “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Element</a>.attributes”
                                                    集合字段时，子对象的
                                                    “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Attribute</a>.quanifiedName”
                                                    和
                                                    “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Attribute</a>.ownerElement”
                                                    字段均会被自动修改。
                                                </li>
                                            </ul>
                                        </fieldset>
                                        <fieldset class="tree-node method">
                                            <legend>testCreateTreeBySetParentOfChild</legend>
                                            <p>
                                                演示以将父对象赋值给子对象的引用属性的方式创建XML节点树。
                                            </p>
                                            <ul>
                                                <li>
                                                    当Node子对象的
                                                    “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.index”
                                                    字段被设置成非-1的值且其
                                                    “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.parentNode”
                                                    字段被设置成非空的父对象时，该子对象将会被自动添加到此父对象的
                                                    “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Element</a>.childNodes” of
                                                    集合字段中去。 
                                                </li>
                                                <li>
                                                    当Attribute子对象的
                                                    “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Attribute</a>.quanifiedName”
                                                    字段被甚至为非空且其
                                                    “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Attribute</a>.ownerElement”
                                                    字段也被设置成非空时，该子对象将会被自动添加到父对象的
                                                    “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Element</a>.attributes” of
                                                    集合字段中去。
                                                </li>
                                            </ul>
                                        </fieldset>
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend>ChangingChildNodeTest.java</legend>
                                        <p>
                                            演示如何改变某个父对象中子对象集合。
                                        </p>
                                        <fieldset class="tree-node method">
                                            <legend>testChangeChildNodeOrderByParent</legend>
                                            <p>
                                                演示将在父Element对象的 
                                                “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.childNodes”
                                                集合字段中已经存在的Element和Comment子对象再次重复地添加到该集合中，以改变子对象顺序的方法。
                                            </p>
                                            <ul>
                                                <li>
                                                    父对象的
                                                    “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.childNodes” 
                                                    并不会因此而包含重复的元素，但其元素顺序会改变。
                                                </li>
                                                <li>
                                                    某些子对象的
                                                    “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.index”
                                                    属性将会被自动改变。
                                                </li>
                                            </ul>
                                        </fieldset>
                                        <fieldset class="tree-node method">
                                            <legend>testChangeChildNodeOrderByChild</legend>
                                            改变某些Element或Comment子对象的
                                            “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.index”
                                            字段。
                                            <ul>
                                                <li>
                                                    这些子对象说属父对象的
                                                    “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.childNodes”
                                                    集合字段的元素顺序会被自动改变。
                                                </li>
                                                <li>
                                                    其它的子对象的
                                                    “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.index”
                                                    字段会被自动修改。
                                                </li>
                                            </ul>
                                        </fieldset>
                                        <fieldset class="tree-node method">
                                            <legend>removeChildByParentIterator</legend>
                                            <p>
                                                演示通过“java.util.Iterator&lt;E&gt”迭代器对父对象的集合字段进行遍历并自动删除Comment子对象元素。
                                            </p>
                                            <ul>
                                                <li>
                                                    对被删除的子对象（Comment）而言，其
                                                    “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.parentNode”
                                                    字段会被自动清空，其
                                                    “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.index”
                                                    字段则会被自动甚至为-1。
                                                </li>
                                                <li>
                                                    对于其他幸存的子对象（Element）而言，其
                                                    “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.index”
                                                    字段会被自动改变。
                                                </li>
                                            </ul>
                                        </fieldset>
                                        <fieldset class="tree-node method">
                                            <legend>removeChildByParentSubListIterator</legend>
                                            和上一个测试方法极为类似，只是这次在集合的subList视图上使用迭代器删除Comment，所以，并不是所有的Comment子对象均会被删除。
                                        </fieldset>
                                        <fieldset class="tree-node method">
                                            <legend>removeChildByChild</legend>
                                            演示通过将某些Comment子对象的
                                            “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.parentNode”
                                            字段设置为空，或将其 
                                            “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.index”
                                            字段设置为-1的方式，删除这些子对象。
                                            <ul>
                                                <li>
                                                    被修改的Comment子对象会自动从其所属父对象的
                                                    “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.childNodes” 
                                                    集合字段中被删除。
                                                </li>
                                                <li> 
                                                    子对象的 
                                                    “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.index”
                                                    和 
                                                    “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.parentNode” 
                                                    字段能相互影响彼此。
                                                    <ul>
                                                        <li>
                                                            如果某对象的 
                                                            “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.index”
                                                            字段为-1，那么对同一个对象的
                                                            “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.parentNode”
                                                            字段而言，即便其真实数据不是null，但从开发人员的角度看起来也表现为null，直到
                                                            “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.index”被修改成不是-1的值为止。
                                                        </li>
                                                        <li>
                                                            如果某对象的
                                                            “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.parentNode”
                                                            字段为null，那么对同一个对象的
                                                            “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.index”
                                                            字段而言，即便其真实数据不是-1，但从开发人员的角度看起来也表现为-1，直到
                                                            “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.parentNode”被修改成非空的值为止。
                                                        </li>
                                                    </ul>
                                                </li>
                                                <li>
                                                    其余幸存子对象的
                                                    “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.index”
                                                    字段会被自动修改。
                                                </li>
                                            </ul>
                                        </fieldset>
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend>MovingChildBetweenDifferentParentsTest.java</legend>
                                        <p>
                                            演示让将一个子对象从它原本所属的旧的父对象之下迁移到新的父对象之下。
                                        </p>
                                        <fieldset class="tree-node method">
                                            <legend>testMoveScriptByChangingParent</legend>
                                            当测试完成初始化之后，&lt;script/&gt;元素并定义在&lt;body/&gt;元素之下。
                                            该方法演示通过将&lt;script/&gt;添加到&lt;head/&gt; 的
                                            “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.childNodes”
                                            集合字段之中的方法，来将&lt;script/&gt;迁移到&lt;head/&gt; 之下。
                                            <ul>
                                                <li>
                                                    &lt;script/&gt;会从其所属的旧的父对象&lt;body/&gt;的
                                                    “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.childNodes”
                                                    集合字段中被自动删除。
                                                </li>
                                                <li>
                                                    &lt;script/&gt;的
                                                    “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.parentNode” 
                                                    会被自动设置成新的父对象&lt;head/&gt;。
                                                </li>
                                                <li>
                                                    在迁移之前，&lt;div/&gt;节点的
                                                    “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.index“
                                                    字段为1；而迁移完成之后，此属性被自动修改成了0。
                                                </li>
                                            </ul>
                                        </fieldset>
                                        <fieldset class="tree-node method">
                                            <legend>testMoveScriptByChaningItself</legend>
                                            当测试完成初始化之后，&lt;script/&gt;元素并定义在&lt;body/&gt;元素之下。
                                            该方法演示通过将&lt;script/&gt;的
                                           “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.parentNode”
                                            引用字段设置为&lt;head/&gt;的方法，来将&lt;script/&gt;迁移到&lt;head/&gt; 之下。
                                            <ul>
                                                <li>
                                                    &lt;script/&gt;会从其所属的旧的父对象&lt;body/&gt;的
                                                    “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.childNodes”
                                                    集合字段中被自动删除。
                                                </li>
                                                <li>
                                                    &lt;script/&gt;会被自动添加到&lt;head/&gt;的
                                                    “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.childNodes”
                                                    集合字段中去。
                                                </li>
                                                <li>
                                                    在迁移之前，&lt;div/&gt;节点的
                                                    “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.index“
                                                    字段为1；而迁移完成之后，此属性被自动修改成了0。
                                                </li>
                                            </ul>
                                        </fieldset>
                                        <fieldset class="tree-node method">
                                            <legend>testMoveNgInitByChangingParent</legend>
                                            当测试完成初始化之后，XML属性“ng-init=...”属于XML元素“&lt;div&gt;”。
                                            该方法演示通过将XML属性“ng-init=...”添加到&lt;body/&gt;元素的的
                                            “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Element</a>.attributes” 
                                            集合字段之中的方法，将该属性迁移到&lt;body/&gt;元素上。
                                            <ul>
                                                <li>
                                                    XML属性“ng-init...”将会被从其所属的旧的父对象&lt;div/&gt；的
                                                    “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Element</a>.attributes”
                                                    集合字段中被自动移除。
                                                </li>
                                                <li>
                                                    XML属性“ng-init...”的
                                                    “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Attribute</a>.ownerElement”
                                                    字段将会被自动设置为&lt;body/&gt;。
                                                </li>
                                            </ul>
                                        </fieldset>
                                        <fieldset class="tree-node method">
                                            <legend>testMoveNgInitByChangingItself</legend>
                                            当测试完成初始化之后，XML属性“ng-init=...”属于XML元素“&lt;div&gt;”。
                                            该方法演示通过将XML属性“ng-init=...”的
                                            "<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Attribute</a>.ownerElement"
                                            引用字段设置为的&lt;body/&gt;元素方法，将该属性迁移到&lt;body/&gt;元素上。
                                            <ul>
                                                <li>
                                                    XML属性“ng-init...”将会被从其所属的旧的父对象&lt;div/&gt；的
                                                    “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Element</a>.attributes”
                                                    集合字段中被自动移除。
                                                </li>
                                                <li>
                                                    XML属性“ng-init...”将会被添加到新的父对象&lt;body/&gt;的
                                                    “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Element</a>.attributes"
                                                    集合字段中去。
                                                </li>
                                            </ul>
                                        </fieldset>
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend>ChangingAttributeByIteratorTest.java</legend>
                                        <fieldset class="tree-node method">
                                            <legend>testRemoveAttributesByMapKeySetViewIterator</legend>
                                            对每一个
                                            <a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Element</a>对象, 
                                            获取其
                                            “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Element</a>.attributes“
                                            集合字段的keySet视图，使用迭代器遍历该视图，如果当前被遍历的到的QuanifiedName对象的localName
                                            以“ng-”开头的话，删除之。
                                            <ul>
                                                <li>
                                                    所有因localName以“ng-”开头的XML属性对象的
                                                    “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Attribute</a>.ownerElement”
                                                    字段均会被自动设置成null。
                                                </li>
                                            </ul>
                                        </fieldset>
                                        <fieldset class="tree-node method">
                                            <legend>testRemoveAttributesByMapValuesViewIterator</legend>
                                            对每一个
                                            <a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Element</a>对象, 
                                            获取其
                                            “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Element</a>.attributes”
                                            集合字段的values视图，使用迭代器遍历该视图，如果当前被遍历到的Attribute对象的localName
                                            以“data-”开头且其value为偶数，删除之。
                                            <ul>
                                                <li>
                                                    所有因localName以“data-”开头且值为偶数的的XML属性对象的
                                                    “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Attribute</a>.ownerElement”
                                                    字段均会被自动设置成null。
                                                </li>
                                            </ul>
                                        </fieldset>
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend>UnstableMapKeyTest.java</legend>
                                        <fieldset class="tree-node method">
                                            <legend>testChangeKeyToNewData</legend>
                                            <p>
                                                在这个测试方法中，一个已经被添加到某个Element父对象的
                                                ”<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Element</a>.attributes“
                                                的集合字段中的Attribute对象的
                                                “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Attribute</a>.quanifiedName”
                                                字段被修改。
                                            </p>
                                            <p>
                                                幸运的是，其所属父对象的
                                                “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Element</a>.attributes”
                                                支持X/MA集合框架的“不稳定集合元素功能”，该Map集合会在其键对象被开发人员修改时被自动调整。
                                            </p>
                                        </fieldset>
                                        <fieldset class="tree-node method">
                                            <legend>testChangeKeyToConflictData</legend>
                                            <p>
                                                在这个测试方法中，不仅是一个已经被添加到某个Element父对象的
                                                ”<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Element</a>.attributes“
                                                的集合字段中的Attribute对象的
                                                “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Attribute</a>.quanifiedName”
                                                字段被修改，而且修改后属性对象的quanifiedName字段的新值会和父对象中另外一个属性对象的quanifiedName字段冲突。
                                            </p>
                                            <p>
                                                幸运的是，
                                            </p>
                                            <ul>
                                                <li>
                                                    集合属性
                                                    “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Element</a>.attributes”
                                                    既然支持“不稳定集合元素功能”，当然也包含其子集功能“元素排挤效应”，父对象中另外的那一个quanifiedName字段
                                                    即将同修改值冲突的另外一个Attribute对象会被自动从此Map种删除。
                                                </li>
                                                <li>
                                                    为了保证双向关联两端的一致性，被排挤掉的那个Attribute对象的
                                                    “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Attribute</a>.ownerElement”
                                                    字段也会被自动设置为null。
                                                </li>
                                            </ul>
                                        </fieldset>
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend>ValidatorTest.java</legend>
                                        <fieldset class="tree-node method">
                                            <legend>testValidatorByCollection</legend>
                                            演示无法为
                                            <a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Element</a>
                                            类型的对象的
                                            “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.childNodes”
                                            集合字段添加
                                            <a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Attribute</a> 
                                            类型的的子对象，因为那个集合属性使用验证器以保证它仅仅能包含类型为
                                            because that collection uses the validator to restrict its elements can only be 
                                            <a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Element</a>, 
                                            <a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Text</a> 
                                            或
                                            <a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Comment</a>的对象。
                                        </fieldset>
                                        <fieldset class="tree-node method">
                                            <legend>testValidatorByReference</legend>
                                            <p>
                                                演示无法将
                                                <a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Attribute</a>
                                                类型的对象的
                                                “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.parentNode”
                                                字段设置为
                                                <a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Element</a>
                                                类型的对象。.
                                            </p>
                                            <p>
                                                虽然
                                                <a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Attribute</a>
                                                类并未对
                                                "<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.parentNode"
                                                字段添加任何验证器,
                                                但是，当其"parentNode"字段修改成一个新Element对象时, ObjectModel会将此Attribute对象自动添加到那个新Element对象的
                                                “<a href="!project/:main/:type">org.babyfishdemo.om4java.dom.Node</a>.childNodes”
                                                集合字段中，最终会导致该集合字段的验证器报错。
                                            </p>
                                        </fieldset>
                                    </fieldset>
                                </fieldset>
                            </fieldset>
                        </fieldset>
                    </fieldset>
                    <fieldset class="tree-node category">
                        <legend>Demos for JPA</legend>
                        <fieldset class="tree-node project">
                            <legend>babyfishdemo-om4jpa</legend>
                            <div class="info">
                                <ul>
                                    <li>
                                        为了支持JPA实体对象，BabyFish基于ObjectModelJava扩展出了ObjectModel4JPA。
                                        ObjectModel4JPA的功能和ObjectModel4Java的功能非常类似，
                                        而后者的功能已经在<a href="#babyfishdemo-om4java">babyfishdemo-om4java</a>
                                        和<a href="#babyfishdemo-om4java-dom">babyfishdemo-om4java-dom</a>中得到了足够多的示范，
                                        所以，没有必要在本章节再次重复演示。这就是为什么本工程产品代码目录下有很多实体类但缺乏相应单元测试的原因。
                                    </li>
                                    <li>
                                        很多JPA实体类使用了
                                        <a href=":github/src/babyfish-jpa-model/:main/:type">@org.babyfish.model.jpa.JPAModel</a>
                                        注解，该注解表明该类使用了ObjectModel4JPA，对应地，在<a href="!project/pom.xml">pom.xml</a>
                                        需要定义如下的Maven插件来完成ObjectModel4JPA所需要的编译字节码增强。
                                        <div class="code">
                                            <pre><code>&lt;plugin&gt;
    &lt;groupId&gt;org.babyfish&lt;/groupId&gt;
    &lt;artifactId&gt;
        babyfish-instrument-maven-plugin
    &lt;/artifactId&gt;
    &lt;version&gt;${babyfish.version}&lt;/version&gt;
    &lt;executions&gt;
    &lt;execution&gt;
        &lt;goals&gt;
        &lt;goal&gt;instrument&lt;/goal&gt;
        &lt;/goals&gt;
    &lt;/execution&gt;
    &lt;/executions&gt;
    &lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.babyfish&lt;/groupId&gt;
        &lt;artifactId&gt;
            babyfish-hibernate-model-tool
        &lt;/artifactId&gt;
        &lt;version&gt;${babyfish.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/plugin&gt;</code></pre>
                                        </div>
                                    </li>
                                </ul>
                            </div>
                            <fieldset class="tree-node folder">
                                <legend>src/main/java</legend>
                                <fieldset class="tree-node package">
                                    <legend>org.babyfishdemo.om4jpa.entities.r2r</legend>
                                    <p>
                                        此包演示如何使用ObjectModel4JPA声明双向一对一关系。
                                    </p>
                                    <div class="info">
                                        <ul>
                                            <li>
                                                相似的功能在ObjectModel4Java的演示包
                                                <a href="#om4java.r2r">org.babyfishdemo.om4java.r2r</a>
                                                中已经被演示过，此处没必要再次演示。
                                            </li>
                                            <li>
                                                和ObjectModel4Java有一点细微区别，ObjectModel4Java允许一个关联字段自己和自己互为镜像；
                                                但是，ObjectModel4JPA必须遵循JPA的规则，开发人员必须使用两个不同的关联字段来构建双向关联。
                                            </li>
                                        </ul>
                                    </div>
                                </fieldset>
                                <fieldset class="tree-node package">
                                    <legend>org.babyfishdemo.om4jpa.entities.s2r</legend>
                                    <p>
                                        此包演示如何使用ObjectModel4JPA创建双向一对多关系。
                                    </p>
                                    <div class="info">
                                        相似的功能在ObjectModel4Java的演示包
                                        <a href="#om4java.s2r">org.babyfishdemo.om4java.s2r</a>
                                        中已经被演示过，此处没必要基于单元测试再次演示。
                                    </div>
                                </fieldset>
                                <fieldset class="tree-node package">
                                    <legend>org.babyfishdemo.om4jpa.entities.l2ir</legend>
                                    <p>
                                        此包演示如何使用ObjectModel4JPA声明让子对象维护自己在所属父对象的List集合字段中的索引的双向一对多关系。
                                    </p>
                                    <ul>
                                        <li>
                                            “<a href='!project/:main/:type'>org.babyfishdemo.om4jpa.entities.l2ir.Employee</a>.index”
                                            字段被
                                            <a href=':jee-api/:type'>@javax.persistence.Column</a>
                                            注解修饰，注解的参数表明其在数据库的当前表中对应的列名是INDEX_IN_DEPARTMENT。
                                        </li>
                                        <li>
                                            “<a href='!project/:main/:type'>org.babyfishdemo.om4jpa.entities.l2ir.Department</a>.employees”
                                            字段被
                                            <a href=':jee-api/:type'>@javax.persistence.OrderColumn</a>
                                            注解修饰，注解的参数表明此List的元素索引在数据库的子表中对应的列名也是INDEX_IN_DEPARTMENT。
                                        </li>
                                        <li>
                                            <ul>
                                                <li>
                                                    综合上述两点，
                                                    “<a href='!project/:main/:type'>org.babyfishdemo.om4jpa.entities.l2ir.Employee</a>.index”
                                                    是一个特殊的字段，它用于指明当前对象在
                                                    “<a href='!project/:main/:type'>org.babyfishdemo.om4jpa.entities.l2ir.Employee</a>.department”
                                                    关联字段所指向的父对象的
                                                    “<a href='!project/:main/:type'>org.babyfishdemo.om4jpa.entities.l2ir.Department</a>.employees”
                                                    List集合字段中的索引。
                                                </li>
                                                <li>
                                                    但是，JPA的这种约定略显隐晦，为了提高代码可读性，ObjectModel4JPA强制要求开发人员对
                                                    ”<a href='!project/:main/:type'>org.babyfishdemo.om4jpa.entities.l2ir.Employee</a>.index“
                                                    字段使用
                                                    <a href=':github/src/babyfish-model/:main/:type'>@org.babyfish.model.IndexOf</a>
                                                    注解。
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                    <div class="info">
                                        相似的功能在ObjectModel4Java的演示包
                                        <a href="#om4java.l2ir">org.babyfishdemo.om4java.l2ir</a>
                                        中已经被演示过，此处没必要基于单元测试再次演示。
                                    </div>
                                </fieldset>
                                <fieldset class="tree-node package">
                                    <legend>org.babyfishdemo.om4jpa.entities.l2r</legend>
                                    <p>
                                        此包演示如何使用ObjectModel4JPA声明基于java.util.List的双向一对多关联。
                                    </p>
                                    <div class="info">
                                        相似的功能在ObjectModel4Java的演示包
                                        <a href="#om4java.l2r">org.babyfishdemo.om4java.l2r</a>
                                        中已经被演示过，此处没必要基于单元测试再次演示。
                                    </div>
                                </fieldset>
                                <fieldset class="tree-node package">
                                    <legend><a id="om4jpa.m2kr_1">org.babyfishdemo.om4jpa.entities.m2kr_1</a></legend>
                                    <p>
                                        此包演示如何使用ObjectModel4JPA声明让子对象维护自己在所属父对象的Map集合字段中的键的双向一对多关系。
                                    </p>
                                    <ul>
                                        <li>
                                            字段
                                            “<a href='!project/:main/:type'>org.babyfishdemo.om4jpa.entities.m2kr_1.Employee</a>.key”
                                            被
                                            <a href=':jee-api/:type'>@javax.persistence.Column</a>
                                             注解修饰，注解的参数表明其在数据库的当前表中对应的列名是KEY_IN_DEPARTMENT。
                                        </li>
                                        <li>
                                            字段
                                            "<a href='!project/:main/:type'>org.babyfishdemo.om4jpa.entities.m2kr_1.Department</a>.employees"
                                            被
                                            <a href=':jee-api/:type'>@javax.persistence.MapKeyColumn</a>
                                            注解修饰，注解的参数表明此Map的键在数据库的子表中对应的列名也是KEY_IN_DEPARTMENT。
                                        </li>
                                        <li>
                                            <ul>
                                                <li>
                                                    综合上述两点，
                                                    "<a href='!project/:main/:type'>org.babyfishdemo.om4jpa.entities.m2kr_1.Employee</a>.key"
                                                    是一个特殊的字段，它用于指明当前对象在
                                                    “<a href='!project/:main/:type'>org.babyfishdemo.om4jpa.entities.m2kr_1.Employee</a>.department”
                                                    关联字段所指向的父对象的
                                                    "<a href='!project/:main/:type'>org.babyfishdemo.om4jpa.entities.m2kr_1.Department</a>.employees"
                                                    Map集合字段中的键。
                                                </li>
                                                <li>
                                                    但是，JPA的这种约定略显隐晦，为了提高代码可读性，ObjectModel4JPA强制要求开发人员对
                                                    “<a href='!project/:main/:type'>org.babyfishdemo.om4jpa.entities.m2kr_1.Employee</a>.key”
                                                    字段使用
                                                    <a href=':github/src/babyfish-model/:main/:type'>@org.babyfish.model.KeyOf</a>
                                                    注解。
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                    <div class="info">
                                        相似的功能在ObjectModel4Java的演示包
                                        <a href="#om4java.m2kr">org.babyfishdemo.om4java.m2kr</a>
                                        中已经被演示过，此处没必要基于单元测试再次演示。
                                    </div>
                                </fieldset>
                                <fieldset class="tree-node package">
                                    <legend>org.babyfishdemo.om4jpa.entities.m2kr_2</legend>
                                    <p>
                                        这例子和上个例子
                                        <a href="#om4jpa.m2kr_1">org.babyfishdemo.om4jpa.entities.m2kr_1</a>
                                        极其相似，有两点区别:
                                    </p>
                                    <ul>
                                        <li>
                                            “<a href='!project/:main/:type'>org.babyfishdemo.om4jpa.entities.m2kr_2.Employee</a>.key"
                                            字段不再是类似于String这种简单类型，它是另外一个使用了
                                            <a href=':jee-api/:type'>@javax.persistence.Embeddable</a>
                                            注解的内嵌模型类
                                            <a href='!project/:main/:type'>org.babyfishdemo.om4jpa.entities.m2kr_2.Key</a>。
                                        </li>
                                        <li>
                                            “<a href='!project/:main/:type'>org.babyfishdemo.om4jpa.entities.m2kr_2.Department</a>.employees”
                                            字段不再使用
                                            <a href=':jee-api/:type'>@javax.persistence.MapKeyColumn</a>，
                                            注解，而是使用
                                            <a href=':jee-api/:type'>@javax.persistence.MapKey</a>
                                            注解。
                                        </li>
                                    </ul>
                                </fieldset>
                                <fieldset class="tree-node package">
                                    <legend>org.babyfishdemo.om4jpa.entities.s2s</legend>
                                    <p>
                                        此包演示如何使用ObjectModel4JPA声明让基于java.util.Set和java.util.Set构建的双向一对多关系。
                                    </p>
                                    <div class="info">
                                        相似的功能在ObjectModel4Java的演示包
                                        <a href="#om4java.s2s">org.babyfishdemo.om4java.s2s</a>，
                                        中已经被演示过，此处没必要基于单元测试再次演示。
                                    </div>
                                </fieldset>
                                <fieldset class="tree-node package">
                                    <legend>org.babyfishdemo.om4jpa.entities.l2s</legend>
                                    <p>
                                        此包演示如何使用ObjectModel4JPA声明让基于java.util.List和java.util.Set构建的双向一对多关系。
                                    </p>
                                    <div class="info">
                                        相似的功能在ObjectModel4Java的演示包
                                        <a href="#om4java.l2s">org.babyfishdemo.om4java.l2s</a>，
                                        中已经被演示过，此处没必要基于单元测试再次演示。
                                    </div>
                                </fieldset>
                                <fieldset class="tree-node package">
                                    <legend>org.babyfishdemo.om4jpa.entities.m2s</legend>
                                    <p>
                                        此包演示如何使用ObjectModel4JPA声明让基于java.util.Map和java.util.Set构建的双向一对多关系。
                                    </p>
                                    <div class="info">
                                        相似的功能在ObjectModel4Java的演示包
                                        <a href="#om4java.m2s">org.babyfishdemo.om4java.m2s</a>
                                        中已经被演示过，此处没必要基于单元测试再次演示。
                                    </div>
                                </fieldset>
                                <fieldset class="tree-node package">
                                    <legend>org.babyfishdemo.om4jpa.entities.comparator</legend>
                                    <p>
                                        此包演示如何使用ObjectModel4JPA为一个工作模式类似于java.util.HashSet的关联字段声明hashCode计算规则和相等性判断段规则。
                                    </p>
                                    <div class="info">
                                        相似的功能在ObjectModel4Java的演示包
                                        <a href="#om4java.fec">org.babyfishdemo.om4java.fec</a>
                                        中已经被演示过，此处没必要基于单元测试再次演示。
                                    </div>
                                </fieldset>
                                <fieldset class="tree-node package">
                                    <legend>org.babyfishdemo.om4jpa.entities.navigable</legend>
                                    <p>
                                        此包演示如何使用ObjectModel4JPA为一个工作模式类似于java.util.TreeSet的关联字段声明对象大小比较规则。
                                    </p>
                                    <div class="info">
                                        <ul>
                                            <li>
                                                和ObjectModel4Java不同，ObjectModel4JPA必须遵循JPA规范，不允许开发人员将
                                                关联字段的类型声明成java.util.SortedSet&lt;E&gt;，java.util.NavigableSet&lt;E&gt;，
                                                java.util.SortedMap&lt;K，V&gt;或java.util.NavigableMap&lt;K，V&gt;"。
                                                请将字段声明成普通的java.util.Set&lt;E&gt;或java.util.Map&lt;K，V&gt;接口并对之使用
                                                <a href=':github/src/babyfish-model/:main/:type'>org.babyfish.model.Navigable</a>
                                                注解。
                                            </li>
                                            <li>
                                                相似的功能在ObjectModel4Java的演示包
                                                <a href="#om4java.fc">org.babyfishdemo.om4java.fc</a>
                                                中已经被演示过，此处没必要基于单元测试再次演示。
                                            </li>
                                            </ul>
                                    </div>
                                </fieldset>
                                <fieldset class="tree-node package">
                                    <legend>org.babyfishdemo.om4jpa.entities.contravariance</legend>
                                    <p>
                                        此包演示如何在ObjectModel4JPA中使用
                                        <a href=':github/src/babyfish-model/:main/:type'>org.babyfish.model.Contravariance</a>
                                        注解在派生类中对超类字段进行逆变覆盖。
                                    </p>
                                    <div class="info">
                                        <ul>
                                            <li>
                                                和ObjectModel4Java不同，对于多对一和一对一关联字段而言，超类中的协变字段和派生类中的逆变字段不能同名。
                                            </li>
                                            <li>
                                                相似的功能在ObjectModel4Java的演示包
                                                <a href="#om4java.contravariance">org.babyfishdemo.om4java.contravariance</a>
                                               注解在派生类中对超类字段进行逆变覆盖。
                                            </li>
                                        </ul>
                                    </div>
                                </fieldset>
                            </fieldset>
                            <fieldset class="tree-node folder">
                                <legend>src/test/java</legend>
                                <fieldset class="tree-node package">
                                    <legend>org.babyfishdemo.om4jpa.disability</legend>
                                    <p>
                                        ObjectModel4JPA支持一个对实际项目很有帮助的功能："disability"，用户支持不完整实体对象。
                                        即对一个实体对象而言，某些属性可以被启用而另外一些属性可以被禁用。
                                    </p>
                                    <fieldset class="tree-node file">
                                        <legend>JPAMergingTest.java</legend>
                                        <p>
                                            此测试类演示Hibernate的内部机制被替换。
                                        </p>
                                        <p>
                                            当一个不完整实体对象被通过调用
                                            <a href=":jee-api/javax/persistence/EntityManager.html#merge-T-">javax.persistence.EntityManager.merge(T)</a>
                                            想数据中保存时，在事务提交后，只有启用的字段会被更新，被禁用的字段不会被更新。
                                        </p>
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend>BookServiceTest.java</legend>
                                        <p>
                                            此测试类演示如何使用JPAEntities验证API支持安全的业务接口。
                                        </p>
                                        <p>
                                            BabyFish支持JPAEntities验证API， 
                                            可以让业务对象限定外界传入的实体对象上被启用的属性的最大范围，当前业务不应该修改的字段一定要是被禁用的，否则抛出异常。
                                            因此，业务接口可以保证仅仅更新当前业务应该更新的字段。
                                        </p>
                                    </fieldset>
                                </fieldset>
                            </fieldset>
                        </fieldset>
                        <fieldset class="tree-node project">
                            <legend><a id="jpa-crtieria">babyfishdemo-jpa-criteria</a></legend>
                            <p>
                                此工程演示BabyFish替换了Hibernate的JPA Criteria实现，提供了另外一套完整的实现。
                            </p>
                            <ul>
                                <li>
                                    为了引入新的功能，BabyFish从<a href=":jee-api/:type">javax.persistence.criteria.CriteriaBuilder</a>
                                    扩展出了
                                    <a href=":github/src/babyfish-jpa-extension/:main/:type">org.babyfish.persistence.criteria.XCriteriaBuilder</a>
                                    接口。
                                </li>
                                <li>
                                    本框架中很多JPA相关的演示程序使用JPA Critera，而非JPQL(或NamedQuery，Spring-Data-JPA)，因为
                                </li>
                                <li>
                                    <ul>
                                        <li>
                                            和JPQL不同，BabyFish对JPA Criteria的实现具备某些性能优化。
                                        </li>
                                        <li>
                                            对于Java语言而言，JPQL仅仅是一个普通的字符串而已，任何JPQL的错误都要滞后到运行后才能报告.。
                                            在运行或测试程序之间不容易保证JPQL一定是正确的，增加了调试程序所需要的时间。
                                        </li>
                                        <li>
                                            在实际项目中，当实体对象被重构时，Criteria API能马上报告编译错误，直到整个重构完全完成为止。
                                            但是JPQL因重构遗漏而导致的错误只能通过单元测试和集成测试发现，这对重构而言是非常危险的，尤其是当你的项目的测试覆盖率不能达到100%时。
                                            更何况，修复运行错的代价总比修复编译错误的代价大。
                                            <div class="warning">
                                                重构效率往往比首次书写效率更为重要，尤其是对大项目而言。
                                            </div>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                            <fieldset class="tree-node folder">
                                <legend>src/test/java</legend>
                                <fieldset class="tree-node package">
                                    <legend>org.babyfishdemo.jpacriteria</legend>
                                    <fieldset class="tree-node file">
                                        <legend>NullableExpressionTest.java</legend>
                                        <p>
                                            和
                                            <a href=":jee-api/:type">javax.persistence.criteria.CriteriaBuilder</a>
                                            的默认实现中的and，or和not方法不同，
                                            <a href=":github/src/babyfish-jpa-extension/:main/:type">org.babyfish.persistence.criteria.XCriteriaBuilder</a> 
                                            的实现中的这些方法可以接受null参数，这对动态查询而言尤其重要。   
                                        </p>
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend>LiteralAndConstantTest.java</legend>
                                        本测试演示
                                        <a href=":github/src/babyfish-jpa-extension/:main/:type">org.babyfish.persistence.criteria.XCriteriaBuilder</a>的
                                        literal方法和constant方法的区别（后者是BabyFish引入的全新行为）。
                                        <fieldset class="tree-node method">
                                            <legend>testLiteral</legend>
                                            <p>
                                                Hibernate将数字类型的字面量直接转换层SQL语句中的数字字面量，因为
                                                Hibernate认为数字类型的字面量并不会引入注入式攻击的问题。 
                                                但是，这会导致性能问题，Hibernate内部的HQL执行计划缓存和
                                                数据库产品内部的SQL执行计划缓存的命中率皆会降低。
                                            </p>
                                            <p>
                                                在BabyFish中，
                                                “<a href=":jee-api/:type">javax.persistence.criteria.CriteriaBuilder</a>.literal()”
                                                方法采用了Open-JPA风格的实现：字面量总是会被转译成SQL参数，让SQL本身的字符串固化，提高Hibenrate内部
                                                的HQL执行计划缓存和数据库产品内部的SQL执行计划缓存的命中率。
                                            </p>
                                            <div class="info">
                                                在实际项目中，请并忘记
                                                ”<a href=":jee-api/:type">javax.persistence.criteria.CriteriaBuilder</a>.parameter()，
                                                并总是使用
                                                “<a href=":jee-api/:type">javax.persistence.criteria.CriteriaBuilder</a>.literal()”，
                                                这样会让你的工作更简单。
                                            </div>
                                        </fieldset>
                                        <fieldset class="tree-node constant">
                                            <legend>testConstant</legend>
                                            以Oracle为代表的某些数据库支持函数索引，为此，BabyFish支持
                                            “<a href=":github/src/babyfish-jpa-extension/:main/:type">org.babyfish.persistence.criteria.XCriteriaBuilder</a>.constant()”
                                            方法用户创建常量表达式，和字面量表达式不同，常量表达式会被转译成SQL字面量，而非参数。
                                            在数据库产品中基于包含这些常量表达式的复合表达式创建函数索引，能起到性能优化得目的。
                                        </fieldset>
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend>InPredicateTest.java</legend>
                                        <p>
                                            “表达式 in (...)”在实际项目中总是一个很有用的功能，使用频率很高。 
                                            遗憾的是，Oracle数据库并不允许in表达式列表超过1000个值。
                                        </p>
                                        <p>
                                            BabyFish解决了此问题，开发人员可以尽管使用
                                            “<a href=":jee-api/:type">javax.persistence.criteria.CriteriaBuilder</a>.in”
                                            方法构建超过1000个列表值的列表表达式，照样可以在Oracle上运行。因为，对于多于1000个值的in表达式，
                                            BabyFish JPA Criteria最终生成的JPQL语句是这样的
                                        </p>
                                        <div class="code"><pre>
expr in(value1，value2，...，value1000) 
or
expr in(value1001，value1002，...，value2000) 
or
... ...
or
expr in(... ...)  
                                        </pre></div>
                                        <p>
                                            在单元测试中，在Hibernate的数据库方言动了手脚，让其IN表达式仅仅支持10个值，从而方便地演示这个功能。
                                        </p>
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend>JoinModeTest.java</legend>
                                        <p>
                                            BabyFish JPA Criteria API支持
                                            <a href=":github/src/babyfish-jpa-extension/:main/:type">org.babyfish.persistence.criteria.JoinMode</a>
                                            枚举，该枚举有以下4种取值：
                                        </p>
                                        <ul>
                                            <li>OPTIONALLY_MERGE_EXISTS(default)</li>
                                            <li>OPTIONALLY_CREATE_NEW</li>
                                            <li>REQUIRED_TO_MERGE_EXISTS</li>
                                            <li>REQUIRED_TO_CREATE_NEW</li>
                                        </ul>
                                        <p>
                                            此枚举为连接（请注意，这里有中文歧义，此处连接不是指数据库Connection，而是SQL语句的JOIN）模式，在创建连接时使用,
                                            如果当前被创建的连接和其它连接都基于相同的表关系连接条件而形成了冲突和冗余，
                                            此枚举指明是否允许将它们合并成一个连接以让数据库省去不必要的性能开销。
                                        </p>
                                        <fieldset class="tree-node method">
                                            <legend>testCreateNew</legend>
                                            对于基于同样的的表关联连接条件的两个连接，
                                            只要其中任何一个是由OPTIONALLY_CREATE_NEW或REQUIRED_TO_CREATE_NEW创建的，
                                            就不会被合并。
                                        </fieldset>
                                        <fieldset class="tree-node method">
                                            <legend>testMergeExists</legend>
                                            对于基于同样的的表关联连接条件的两个连接，
                                            如果二者都是是由OPTIONALLY_MERGE_EXISTS或REQUIRED_TO_MERGE_EXISTS创建的，
                                            这会被合并。
                                            <div class="warning">
                                                如果两个连接的连接类型（<a href=":jee-api/:type">javax.persistence.criteria.JoinType</a>）不同，
                                                那么合并后的连接类型为INNER JOIN。
                                            </div>
                                        </fieldset>
                                        <fieldset class="tree-node method">
                                            <legend>testOptionalJoinIsIgnored</legend>
                                            如果某个连接由OPTIONALLY_MERGE_EXISTS或OPTIONALLY_CREATE_NEW创建，
                                            如果查询语句中没有任何表达式使用它，则会被忽略，不会在JPQL中生成连接。
                                        </fieldset>
                                        <fieldset class="tree-node method">
                                            <legend>testOptionalJoinIsApplied</legend>
                                            如果某个连接由OPTIONALLY_MERGE_EXISTS或OPTIONALLY_CREATE_NEW创建，
                                            只要查询语句中有任何一个表达式使用它，就不会被忽略，并在JPQL中生成连接。
                                        </fieldset>
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend>ExtTest.java</legend>
                                        演示如何使用org.babyfish.persistence.criteria.ext包下的全新功能。
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend>DynamicQueryTest.java</legend>
                                        通过4种不同的代码风格，演示如何实现动态查询。
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend>OptimizationTest.java</legend>
                                        演示JPA Criteria的JPQL优化能力。
                                    </fieldset>
                                </fieldset>
                            </fieldset>
                        </fieldset>
                        <fieldset class="tree-node project">
                            <legend>babyfishdemo-querypath</legend>
                            QueryPath可以分为两种
                            <ul>
                                <li>
                                    FetchPath: 
                                    <p>
                                        为了动态地实现贪婪加载，BabyFish支持“抓取路径”，
                                        其功能非常类似于
                                    </p>
                                    <ul>
                                        <li><a href="http://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-includes">Active Record的贪婪加载能力</a></li>
                                        <li><a href="https://msdn.microsoft.com/en-us/library/bb738708(v=vs.110).aspx">ADO.NET Entity Framework的贪婪加载能力</a></li>
                                    </ul>
                                    这个功能比从JPA2.1开始支持的
                                    <a href=":jee-api/:type">javax.persistence.EntityGraph</a>
                                    更优雅更强大，请忘记它并在项目中使用BabyFish-JPA或BabyFish-Hibernate提供的FethcPath。
                                </li>
                                <li>SimpleOrderPath，简单排序路径，可以动态地指定如何对查询结果或集合关联进行排序。</li>
                            </ul>
                            <p>
                                本工程会用到有很多以两根下划线（“__”）结尾的类，它们的源代码实在编译时刻自动生成的，在
                                <a href="!project/pom.xml">pom.xml</a>
                                中，你可以看到如下的Maven插件声明：
                            </p>
                            <div class="code">
                                <pre>&lt;plugin&gt;
  &lt;groupId&gt;org.bsc.maven&lt;/groupId&gt;
  &lt;artifactId&gt;maven-processor-plugin&lt;/artifactId&gt;
  &lt;version&gt;2.0.0&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;id&gt;process&lt;/id&gt;
      &lt;goals&gt;
        &lt;goal&gt;process&lt;/goal&gt;
      &lt;/goals&gt;
      &lt;phase&gt;generate-sources&lt;/phase&gt;
      &lt;configuration&gt;
        &lt;outputDirectory&gt;
          ${project.build.directory}/metamodel
        &lt;/outputDirectory&gt;
        &lt;processors&gt;
          &lt;processor&gt;
            org.babyfish.model.jpa.source.TypedQueryPathProcessor
          &lt;/processor&gt;
        &lt;/processors&gt;
      &lt;/configuration&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.babyfish&lt;/groupId&gt;
      &lt;artifactId&gt;babyfish-jpa-model-tool&lt;/artifactId&gt;
      &lt;version&gt;${babyfish.version}&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/plugin&gt;
&lt;plugin&gt;
  &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
  &lt;artifactId&gt;build-helper-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;1.3&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;id&gt;add-source&lt;/id&gt;
      &lt;phase&gt;generate-sources&lt;/phase&gt;
      &lt;goals&gt;
        &lt;goal&gt;add-source&lt;/goal&gt;
      &lt;/goals&gt;
      &lt;configuration&gt;
        &lt;sources&gt;
          &lt;source&gt;
            ${project.build.directory}/metamodel
          &lt;/source&gt;
        &lt;/sources&gt;
      &lt;/configuration&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
&lt;/plugin&gt;</pre>
                            </div>
                            <fieldset class="tree-node folder">
                                <legend>src/test/java</legend>
                                <fieldset class="tree-node package">
                                    <legend>org.babyfishdemo.querypath</legend>
                                    <div class="info">
                                        在实际项目中，请积极使用QueryPath功能以避免 
                                        <ul>
                                            <li>Hiberate的N + 1查询问题。</li>
                                            <li>Spring的Open Session In View方案；业务层才是唯一被允许开启事务的场合【注：Spring的Open Session In View有一个前提，假设程序总是在同一个机器的同一个JVM中运行，无法支持分布式设计是硬伤】。</li>
                                        </ul>
                                    </div>
                                    <fieldset class="tree-node file">
                                        <legend>AssociationFetchPathTest.java</legend>
                                        演示如何使用QueryPath动态地贪婪加载延迟的关联属性。
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend>ScalarFetchPathTest.java</legend>
                                        演示如何使用QueryPath动态地贪婪加载延迟的标量属性（不一定但往往是大字段属性）。
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend>SimpleOrderPathTest.java</legend>
                                        演示如何使用SimpleOrderPath动态地贪对查询结果以及集合关联进行排序。
                                    </fieldset>
                                </fieldset>
                            </fieldset>
                        </fieldset>
                        <fieldset class="tree-node project">
                            <legend>babyfishdemo-paging-query</legend>
                            此工程演示BabyFish提供的分页查询能力，其中最重要的两个功能是
                            <ul>
                                <li>
                                    Unlimited count：
                                    <p>
                                        实际项目中分页查询很普遍，它的实现依赖于两条SQL。
                                    </p>
                                    <ul>
                                        <li>
                                            不考虑分页条件，查询所有满足条的记录的总条数。
                                        </li>
                                        <li>
                                            采用分页条件，查询指定页之内的所有记录的详细信息。
                                        </li>
                                    </ul>
                                    <p>
                                        这两句SQL虽然是不同的，但又有高度的相似性，
                                        当其中一条被改变时，另外一条也要做出相应的修改，这是一件既无聊又容易出错的维护工作。
                                    </p>
                                    <p>
                                        BabyFish支持一个叫“UnlimitedCount”的功能，开发人员只需要根据第二条SQL创建查询对象，并在其上调用
                                        “<a href=':github/src/babyfish-jpa-extension/:main/:type'>org.babyfish.persistence.XQuery</a>.getUnlimitCount()”
                                        方法即可。该方法的内部实现能自动生成第一条SQL并返回满足条件的记录总条数。
                                    </p>
                                </li>
                                <li>
                                    DistinctLimitQuery：这个功能仅仅针对Oracle 数据库才能使用
                                    <p>
                                        Hibernate有一个很大的性能问题。当查询既有分页要求又包含集合关联属性的连接抓取（join fetch）时，
                                        Hibernate会放弃通过SQL语句实现分页，而是先忽略分页将所有满足条件的数据都查询到内存中，然后在内存中完成分页。 
                                    </p>
                                    <p>
                                        BabyFish支持一个名为“DistinctLimitQuery”的功能，
                                        当数据库是Oracle时，即便查询语句既有分页要求又包含集合关联属性的连接抓取，也可以通过SQL语句实现查询层面的分页。
                                    </p>
                                </li>
                            </ul>
                            <fieldset class="tree-node folder">
                                <legend>src/test/java</legend>
                                <fieldset class="tree-node package">
                                    <legend>org.babyfishdemo.pagingquery</legend>
                                    <fieldset class="tree-node file">
                                        <legend>AllRowsTest.java</legend>
                                        此测试类演示
                                        “<a href=':github/src/babyfish-jpa-extension/:main/:type'>org.babyfish.persistence.QueryType</a>.DISTINCT”
                                        和
                                        “<a href=':github/src/babyfish-jpa-extension/:main/:type'>org.babyfish.persistence.QueryType</a>.RESULT”
                                        之间的差异。
                                        <div class="info">
                                            “<a href=':github/src/babyfish-jpa-extension/:main/:type'>org.babyfish.persistence.QueryType</a>.DISTINCT”
                                            是默认行为，因为在实际项目大绝大多数场合下，它显得更实用。
                                        </div>                                    
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend>ResultLimitQueryTest.java</legend>
                                        此测试演示当查询对象的模式为
                                        “<a href=':github/src/babyfish-jpa-extension/:main/:type'>org.babyfish.persistence.QueryType</a>.RESULT”
                                        时，对包含集合关联属性的连接抓取的查询是如何实现分页的。
                                        <div class="warning">
                                            警告！此模式是对连接查询结果进行分页，并不是对被查询的主实体进行分页
                                            (这点和Hibernate经典的QBC查询类似)，此模式很可能并不是你说期望的效果。
                                        </div>
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend>HsqldbMemoryLevelLimitQueryForDistinctTest.java</legend>
                                        <p>
                                            当查询模式为 
                                            "<a href=':github/src/babyfish-jpa-extension/:main/:type'>org.babyfish.persistence.QueryType</a>.DISTINCT"，
                                            且JPQL包含集合关联抓取时，会发生什么?
                                        </p>
                                        <p>
                                            前文提到过，Hibernate会放弃通过SQL语句实现分页，而是先忽略分页将所有满足条件的数据都查询到内存中，然后在内存中完成分页。
                                        </p>
                                        <p>
                                            在BabyFish中
                                        </p>
                                        <ul>
                                            <li>
                                                当数据库是Oracle时，这个性能问题可以被解决，这点会在<a href="#pagingquery.distinctlimitquery">下一个示例</a>中被演示。
                                            </li>
                                            <li>
                                                但是对其他数据库而言，目前BabyFish也没太好的办法，不得不使用原生Hiberate的处理方法，在内存中完成分页。
                                                当然Hibernate也认为这是一个危险的行为，所以它在使用内存分页时，它会向日志文件输出警告级别的日志；
                                                但BabyFish认为这是不够的，因为警告日志难以引起开发人员的注意，很容易被忽略。
                                            </li>
                                        </ul>
                                        <div class="info">
                                            和原生Hibernate的差异
                                            <ul>
                                                <li>
                                                    <p>
                                                        默认情况下，原生Hibernate的内存分页被BabyFish禁用，执行既有分页要求又包含集合关联属性的连接抓取的查询会导致异常。
                                                    </p>
                                                </li>
                                                <li>
                                                    <p>
                                                        如果无条件使用BabyFish改进过的Oracle分页查询，而开发人员愿意承受内存分页的代价而坚持要使用内存分页的话，
                                                        可以在JPA配置中将“babyfish.hibernate.enable_limit_in_memory”配置为“true”。
                                                    </p>
                                                    请查看<a href="!project/:r-test/persistence.xml">src/test/resources/persistence.xml</a>中的
                                                    <div class="code">
                                                        &lt;property name="babyfish.hibernate.enable_limit_in_memory" value="true"/&gt;
                                                    </div>。
                                                </li>
                                            </ul>
                                        </div>
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend><a id="pagingquery.distinctlimitquery">DistinctLimitQueryTest.java</a></legend>
                                        <p>
                                            当数据库是Oracle时，BabyFish能够解决上面讨论过的Hibernate的性能问题，
                                            即便查询语句既有分页要求又包含集合关联属性的连接抓取，也可以通过SQL语句实现查询层面的分页。
                                        </p>
                                        <p>
                                            本测试只能在明确说明数据库为Oracle的情况下才能运行；否则，Maven会忽略它。
                                        </p>
                                        <div class="info">
                                            如果想支持此单元测试，请
                                            <ul>
                                                <li>
                                                    启动Oracle数据库实例，建立一个新用户。建议用户名为babyfish_demo而密码为123。
                                                </li>
                                                <li>
                                                    为Maven的“mvn clean install”命令或Eclipse的JUnit运行配置界面指定如下的VM参数。
                                                    <div class="code">-Doracle=${jdbc_connection_string} -Doracle.user=${oracle.user} -Dpassword=${oracle_password}</div>
                                                    <ul class="italic">
                                                        <li>如果Oracle用户名为babyfish_demo，可以省略参数-Doracle.user</li>
                                                        <li>如果Oracle用户密码为123，可以省略参数-Doracle.password</li>
                                                    </ul>
                                                </li>
                                                <li>
                                                    请使用BabyFish提供的Oracle方言，对于本示例，可以参见<a href="!project/:test/:type">org.babyfishdemo.pagingquery.base.AbstractTest</a>
                                                    中的<a href=":github/src/babyfish-hibernate-extension/:main/:type">org.babyfish.hibernate.dialect.Oracle10gDialect</a>。
                                                </li>
                                            </ul>
                                        </div>
                                        <fieldset class="tree-node method">
                                            <legend>testLimitQueryByDenseRank</legend>
                                            在简单的情况下，对于既有分页要求又包含集合关联属性的连接抓取查询语句，使用Oracle内置的分析函数DENSE_RANK()进行分页。
                                        </fieldset>
                                        <fieldset class="tree-node method">
                                            <legend>testLimitQueryByDistinctRank</legend>
                                            在复杂的情况下，对于既有分页要求又包含集合关联属性的连接抓取查询语句，使用BabyFish框架定义的Oracle分析函数DISTINCT_RANK(ROWID)进行分页。
                                            <div class="info">
                                                <p>
                                                    为了确保分析函数“DISTINCT_RANK“能被自动创建，
                                                    请在JPA配置中将”babyfish.hibernate.create_oracle_distinct_rank“设置为”true“。
                                                </p>
                                                <p>
                                                    请参考
                                                    <a href="!project/:r-test/persistence.xml">src/test/resources/persistence.xml</a>
                                                    中的
                                                    <div class="code">
                                                        &lt;property name="babyfish.hibernate.create_oracle_distinct_rank" value="true"/&gt;
                                                    </div>。
                                                </p>
                                            </div>
                                        </fieldset>
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend>UnlimitedCountOptimizationTest.java</legend>
                                        此测试演示“UnlimitedCount”功能具备优化能力，在不同情况下，会尽可能生成简单的SQL用来查询满足条件的记录的总条数。
                                    </fieldset>
                                </fieldset>
                            </fieldset>
                        </fieldset>
                        <fieldset class="tree-node project">
                            <legend>
                                <span class="comprehensive">
                                    <a id="babyfishdemo-spring">babyfishdemo-spring</a>
                                </span>
                            </legend>
                            <span class="comprehensive">这是JPA部分的综合示例</span>，演示如何在Sring Framework中使用BabyFish-JPA。
                            <div class="warning">
                                本工程并未使用Spring-Data-JPA，BabyFish不推荐使用Spring-Data-JPA。具体原因在 
                                <a href="#jpa-crtieria">babyfishdemo-jpa-criteria</a>章节中有阐述。
                            </div>
                            <fieldset class="tree-node folder">
                                <legend>src/test/java</legend>
                                <fieldset class="tree-node package">
                                    <legend>org.babyfishdemo.spring.dal</legend>
                                    <fieldset class="tree-node file">
                                        <legend>DynamicConditionTest.java</legend>
                                        演示如何在Spring的数据访问类中使用babyfish-jpa-criteria实现动态查询。
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend>QueryPathTest.java</legend>
                                        演示如何在Spring的数据访问类中使用QueryPath。
                                    </fieldset>
                                    <fieldset class="tree-node file">
                                        <legend>PagingQueryForDistinctModeTest.java</legend>
                                        演示如何在Spring的数据访问类中使用分页查询。
                                        <div class="info">
                                            该测试可以在两种模式下运行
                                            <ul>
                                                <li>
                                                    Hsqldb模式
                                                    <p>
                                                        以hsqldb模式执行此测试类非常容易，
                                                        之需要在JPA配置中将“babyfish.hibernate.enable_limit_in_memory”设置为“true”即可。
                                                        请参见<a href="!project/:r-test/unit-test.spring.xml">src/test/resources/unit-test.spring.xml</a>
                                                        中的
                                                        <div class="code">
                                                            &lt;prop key="babyfish.hibernate.enable_limit_in_memory"&gt;true&lt;/prop&gt;
                                                        </div>。
                                                    </p>
                                                </li>
                                                <li>
                                                    Oracle模式
                                                    <p>
                                                        以oracle模式执行此测试类稍微复杂一点，你需要多做一点准备工作。
                                                    </p>
                                                    <ul>
                                                        <li>
                                                            启动Oracle数据库实例，建立一个新用户。建议用户名为babyfish_demo而密码为123。
                                                        </li>
                                                        <li>
                                                            为Maven的“mvn clean install”命令或Eclipse的JUnit运行配置界面指定如下的VM参数。
                                                            <div class="code">-Doracle=${jdbc_connection_string} -Doracle.user=${oracle.user} -Dpassword=${oracle_password}</div>
                                                            <ul class="italic">
                                                                <li>如果Oracle用户名为babyfish_demo，可以省略参数-Doracle.user</li>
                                                                <li>如果Oracle用户密码为123，可以省略参数-Doracle.password</li>
                                                            </ul>
                                                        </li>
                                                        <li>
                                                            使用BabyFish为Oracle提供的Hibernate方言，请参见
                                                            <a href="!project/:test/:type">org.babyfishdemo.spring.dal.base.SpringConfiguration</a>
                                                            中的
                                                            <a href=":github/src/babyfish-hibernate-extension/:main/:type">org.babyfish.hibernate.dialect.Oracle10gDialect</a>。
                                                        </li>
                                                        <li>
                                                            在JPA配置中将“babyfish.hibernate.create_oracle_distinct_rank”设置为true“true”，请参见
                                                            <a href="!project/:r-test/unit-test.spring.xml">src/test/resources/unit-test.spring.xml</a>
                                                            中的
                                                            <div class="code">
                                                                &lt;prop key="babyfish.hibernate.create_oracle_distinct_rank"&gt;true&lt;/prop&gt;
                                                            </div>。
                                                        </li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </div>
                                    </fieldset>
                                </fieldset>
                            </fieldset>
                        </fieldset>
                    </fieldset>
                    <fieldset class="tree-node category">
                        <legend>项目示例</legend>
                        <p>
                            这是关于BabyFish所有项目示例: <a id="babyfishdemo-war3shop">babyfishdemo-war3shop</a>，一个提供虚拟商店的Web引用。
                        </p>
                        <p>
                            从当前版本（1.1）开始，babyfishdemo-war3shop 将被剥离到独立的github repository
                            <a href="https://www.github.com/babyfish-ct/babyfishdemo-war3shop">https://www.github.com/babyfish-ct/babyfishdemo-war3shop</a>中，
                            因为其安装程序包含太多的图片文件以至于原来的框架包显得非常大.
                        </p>
                        <p>
                            即将到来!
                        </p>
                    </fieldset>
                    <div class="author">
                        <p>
                            陈涛
                            <a href="mailto:babyfish-ct@163.com">babyfish-ct@163.com</a>
                        </p>
                        <p>
                            2016年6月21日于成都
                        </p>
                    </div>
                </div>
                <div id="splitterDragging" class="dragging"></div>
            </div>
        </div>
    </body>
</html>
