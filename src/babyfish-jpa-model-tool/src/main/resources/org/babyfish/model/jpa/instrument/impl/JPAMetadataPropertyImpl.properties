contraviancePropertyMissSuperClass                      = Illegal JPA model field "{0}", it's marked by the annotation "@{1}" but the current JPA model class does not inherit any super JPA model class.
noConvarianceProperty                               = Illegal JPA model field "{0}", it uses the annotation "@{1}" with the argument value "{2}", but "{2}" cannot be found in the super JPA model class "{3}"
diffKeyTypeNameOfConvarianceProperty                    = Illegal JPA model field "{0}", it uses the annotation "@{1}" to specify its convariance property "{2}", the key type of current property is "{3}" but the key type of convariance property is "{4}"
sameTargetTypeNameOfConvarianceProperty                 = Illegal JPA model field "{0}", it uses the annotation "@{1}" to specify its convariance property "{2}", but the target type of current field and convariance field are same
illegalTypeOfContravarianceProperty                     = Illegal JPA model field "{0}", it uses the annotation "@{1}" to specify its convariance property "{2}", but the target type "{3}" of the current field isn't the derived type of the target type "{4}" of convariance property
conflictAnnotations                                     = Illegal JPA model field "{0}", it can't be marked by both "@{1}" and "@{2}"
contravariancePropertyMustBeTransient               = Illegal JPA model field "{0}", it has been marked by "@{1}" so that it must be marked by "@{2}" too
targetEntityCanNotBeSpecified                       = Illegal JPA model field "{0}", the argument "targetEntity" of its annotation "@{1}" can't be specified because its declaring class "{2}" has been marked by "@{3}"
requireCollectionField                                  = Illegal JPA model field "{0}", its type must be collection because it's marked by "@{1}"
requireNonCollectionField                           = Illegal JPA model field "{0}", its type can't be collection because it's marked by "@{1}"
explicitJoinCanNotBeMappedBy                            = Illegal JPA model field "{0}", the argument "mappedBy" of its annotation "@{1}" can not be specified because this field is marked by another annotation "@{2}"
explicitOppositeProprtyIsNotExisting                    = Illegal JPA model field "{0}", it's marked by "@{1}" and the argument "mappedBy" is "{2}", but there is no property "{2}" in target class "{3}"
explicitOppositeProprtyCanNotBeSelf                     = Illegal JPA model field "{0}", it's marked by "@{1}" and the argument "mappedBy" is "{2}", but that field is this field itself
declaringClassOfExplicitOppositePropertyShouldBe        = Illegal JPA model field "{0}", it's marked by "@{1}" with the argument "mappedBy" of that annotation to specify its opposite property "{2}", but that opposite property isn't declared in the JPA model class "{3}"
explicitOppositePropertyIsNotAssociation                = Illegal JPA model field "{0}", it's marked by "@{1}" and the argument "mappedBy" is "{2}", but the opposite property "{3}" is not association
explicitOppositePropertySpecifiedMappedBy           = Illegal JPA model field "{0}", it uses the annotation "@{1}" whose argument "mappedBy" is "{2}" to consider "{3}" as opposite property, but the argument "mappedBy" of "@{4}" of that field is specified too
declaringClassOfImplicitOppositePropertyShouldBe        = Illegal JPA model field "{0}", its opposite model field is "{1}" but "{1}" isn't declared in the JPA model class "{2}"
conflictOppositeProperties                              = Illegal JPA model field "{0}", it has two conflict opposite properties: "{1}" and "{2}"
declaringClassOfOppositeIndexPropertyShouldBe       = Illegal JPA model field "{0}", it uses the annotation "@{1}" to specify the index property "{2}" of its opposite property, but the declaring class of "{2}" isn't "{3}"
conflictOppositeIndexProperties                         = Illegal JPA model field "{0}", it uses the annotation "@{1}" to specify the index property of its opposite property, but both "{2}" and "{3}" can be matched
oneToManyIsRequiredWhenOppositeIndexPropertyIsFound     = Illegal JPA model field "{0}", it uses the annotation "@{1}" to specify the index property "{2}" of its opposite property, but the current field does not use the annotation "@{3}"
mappedByIsRequiredWhenOppositeIndexPropertyIsFound      = Illegal JPA model field "{0}", it uses the annotation "@{1}" to specify the index property "{2}" of its opposite property, but the argument "mappedBy" of the annotation "@{3}" of the current field isn't specified
typeOfOppositeIndexPropertyShouldBeInteger              = Illegal JPA model field "{0}", it uses the annotation "@{1}" to specify the index property "{2}" of its opposite property, but the type of "{2}" isn't "int"
mappedByIsForbiddenWhenOppositeIndexPropertyIsNotFound  = Illegal JPA model field "{0}", its annotation "@{1}" cannot find the index property of its opposite property in its target class "{2}", but the argument "mappedBy" of the annotation "@{3}" of the current field is specified
canNotFindOppositeKeyPropertyByMapKey               = Illegal JPA model field "{0}", it uses the annotation "@{1}" with the argument value "{2}" to specify the key property of its opposite property, but JPA model field "{2}" isn't declared in the JPA model class "{3}"
declaringClassOfOppositeKeyPropertyShouldBe             = Illegal JPA model field "{0}", it uses the annotation "@{1}" to specify the key property "{2}" of its opposite property, but the declaring class of "{2}" isn't "{3}"
conflictOppositeKeyProperties                       = Illegal JPA model field "{0}", it uses the annotation "@{1}" to specify the key property of its opposite property, but both "{2}" and "{3}" can be matched
oneToManyIsRequiredWhenOppositeKeyPropertyIsFound   = Illegal JPA model field "{0}", it uses the annotation "@{1}" to specify the key property "{2}" of its opposite property, but the current field does not use the annotation "@{3}"
mappedByIsRequiredWhenOppositeKeyPropertyIsFound        = Illegal JPA model field "{0}", it uses the annotation "@{1}" to specify the key property "{2}" of its opposite property, but the argument "mappedBy" of the annotation "@{3}" of the current field isn't specified
typeOfOppositeKeyPropertyShouldBe                   = Illegal JPA model field "{0}", it uses the annotation "@{1}" to specify the key property "{2}" of its opposite property, but the type of "{2}" isn't "{3}"
mappedByIsForbiddenWhenOppositeKeyPropertyIsNotFound    = Illegal JPA model field "{0}", its annotation "@{1}" cannot find the key property of its opposite property in its target class "{2}", but the argument "mappedBy" of the annotation "@{3}" of the current field is specified
oppositePropertyShouldBeInverse                         = Illegal JPA model field "{0}", it uses the annotation "@{1}" to specify its opposite property "{2}", the current field isn't inverse so that the opposite field should be inverse, but it actually isn't 
oppositePropertyShouldNotBeInverse                      = Illegal JPA model field "{0}", it uses the annotation "@{1}" to specify its opposite property "{2}", the current field is inverse so that the opposite field should not be inverse, but it actually is
requireIndexOrKeyAnnotation                             = Illegal JPA model field "{0}", its reference property is "{1}" but it isn't marked by the annotation "@{2}"
illegalIndexOrKeyAnnotationValue                        = Illegal JPA model field "{0}", its reference property is "{1}" but the argument value of its annotation "@{2}" isn't "{3}"
unexpectedIndexOrKeyAnnotation                          = Illegal JPA model field "{0}", its has no reference property but it's marked by the annotation "@{1}"
unsupportedAnnoatation                                  = Illegal JPA model field "{0}", the annotation "@{1}" is not supported by ObjectModel4JPA
mapKeyRequireOneToMany                                  = Illegal JPA model field "{0}", the annotation "@{1}" can only work with "@{2}"
annotationRequireFieldType                              = Illegal JPA model field "{0}", it's marked by the annotation "@{1}" but its field type isn't "{2}"
fieldTypeRequireAnnotation                              = Illegal JPA model field "{0}", its field type is "{1}" so that any one annotation of "{2}" should be used, but none of them is used
annotationArgumentCanNotBeEmpty                         = Illegal JPA model field "{0}", it's marked by the annotation "@{1}" but the argument "{2}" of that annotation is empty
referencePropertyHasBeenUsed                            = Illegal JPA model field "{0}", it consider "{1}" as its reference property, but "{2}" also consider "{1}" as its reference property
