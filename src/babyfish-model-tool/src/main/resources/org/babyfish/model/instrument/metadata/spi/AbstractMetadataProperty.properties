# Please see the native2ascii maven plugin in the pom.xml of babyfish-parent.
navigableAnnoationRejectOrderedField        = Illegal model field "{0}", it's marked by the annotation "@{1}" but the field type is "{2}"
navigableAnnoationRequireSetOrMap       = Illegal model field "{0}", it's marked by the annotation "@{1}" but the field type is not the derived interface of "{2}" or "{3}"
illegalAssociationTarget                    = Illegal model field "{0}", it's an association property but the opposite model class "{1}" cannot be found
associationTargetModelTypeMustBeReference = Illegal model field "{0}", it's an association property but the model type of the opposite model class "{1}" isn't "{2}" 
rerferenceTargetMustNotBePrimitive          = Illegal model field "{0}", it's an association reference property but the field type is primitive type
mapKeyModelTypeMustBeEmbedded           = Illegal model field "{0}", it's an association map property, the map key type "{1}" is neither simple type nor another model class whose model type is "{2}"
nonAssociationTargetModelTypeMustBeEmbedded   = Illegal model field "{0}", its target type "{1}" is neither simple type nor another model class whose model type is "{2}"
mapKeyModelIsNotInstrumented                = Illegal model field "{0}", it's an association map property, the map key type "{1}" is another model class which is forgotten to be instrumented
nonAssociationTargetModelIsNotInstrumented  = Illegal model field "{0}", its target type "{1}" is another model class which is forgotten to be instrumented
illegalMapKey                           = Illegal model field "{0}", it's an association map property, the map key type "{1}" is illegal
illegalNonAssociationTarget                 = Illegal model field "{0}", its target type "{1}" is illegal 
collectionTypeMustBeGenericType             = Illegal model field "{0}", its type is collection but isn't generic type
genericTypeArgumentMustBeClass              = Illegal model field "{0}", its generic type parameter[{1}] is not class
illegalOppositeAssociationType              = Illegal model field "{0}", it creates bidirectional association with the opposite field "{1}", the association type of current field is "{2}" so that the association type of opposite field should be any one of "{3}", but it actually is "{4}"
illegalDeclaringClassOfOppositeProperty     = Illegal model field "{0}", it creates bidirectional association with the opposite field "{1}", but the declaring class of opposite field isn't "{2}"
differentKeyTypeName                        = Illegal model field "{0}", it creates bidirectional association with the opposite field "{1}", the key type of this field is "{2}" but the key type of opposite field is "{3}"
oppositePropertyMustBeContravariance        = Illegal model field "{0}", it creates bidirectional association with the opposite field "{1}", the current property is contravanice property but the opposite fild isn't
sortedSetRequireComparatorRule              = Illegal model field "{0}", its type is compatible with "java.util.SortedSet" so that the annotation "@{1}" is required
comparatorRuleCanOnlyBeUsedByAssociation    = Illegal model field "{0}", it's marked by the annotation "@{1}" but it isn't association field
emptyComparatorRuleProperties           = Illegal model field "{0}", it uses the annotation "@{1}" without any properties, please specify one property at least
noComparatorRuleProperty                    = Illegal model field "{0}", it uses the annotation "@{1}" to specify the comparator property name "{2}" but "{2}" is not a field of target class "{3}"
nonScalarComparatorRuleProperty             = Illegal model field "{0}", it uses the annotation "@{1}" to specify the comparator property "{2}", but "{2}" is not scalar field
arrayComparatorRuleProperty                 = Illegal model field "{0}", it uses the annotation "@{1}" to specify the comparator property "{2}", but the type of "{2}" is array 
nonComparableComparatorRuleProperty         = Illegal model field "{0}", it uses the annotation "@{1}" to specify the comparator property "{2}", but the type "{3}" of that comparator property is neither another model class whose mode type is "{4}" nor the type which is compatible with "{5}" 
stringComparatorTypeForNonStringProperty    = Illegal model field "{0}", it uses the annotation "@{1}" to specify the comparator property "{2}" with the argument "stringComparatorType", but the type of that comparator property is not string
nullComparatorTypeForNonStringProperty      = Illegal model field "{0}", it uses the annotation "@{1}" to specify the comparator property "{2}" with the argument "nullComparatorType", but the type of that comparator property is primitive type
duplicateComparatorRuleProperty             = Illegal model field "{0}", it uses the annotation "@{1}" to specify the comparator property "{2}" more than once, each property can only be specified once at most
